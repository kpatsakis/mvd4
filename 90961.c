static int CVE_2013_7268_VULN_ipx_recvmsg(struct kiocb *iocb, struct socket struct msghdr *msg, size_t size, int flags) struct sock * sk = sock -> sk ; struct ipx_sock * ipxs = ipx_sk ( sk ) ; if ( ! ipxs -> port )  struct sockaddr_ipx uaddr ; uaddr . sipx_port = 0; uaddr . sipx_network = 0; if ( ! ipxs -> intrfc )  memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ); rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ); if ( rc )  skb = skb_recv_datagram ( sk , flags & ~MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ); if ( ! skb )  ipx = ipx_hdr ( skb ); copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ); if ( copied > size )  rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ); if ( rc )  if ( skb -> tstamp . tv64 )  sk -> sk_stamp = skb -> tstamp; sipx -> sipx_port = ipx -> ipx_source . sock; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ); sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net; sipx -> sipx_type = ipx -> ipx_type; sipx -> sipx_zero = 0; rc = copied; skb_free_datagram ( sk , skb ); release_sock ( sk ); return rc ; 