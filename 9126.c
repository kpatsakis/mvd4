static dissect_http(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) http_conv_t * conv_data ; int offset = 0 ; int len ; conv_data = get_http_conversation_data ( pinfo ); static http_conv_t get_http_conversation_data(packet_info *pinfo) conversation_t * conversation ; http_conv_t * conv_data ; conversation = find_or_create_conversation ( pinfo ); conv_data = conversation_get_proto_data ( conversation , proto_http ); if ( ! conv_data )  conv_data = se_alloc0 ( sizeof ( http_conv_t ) ); return conv_data ; if ( pinfo -> fd -> num >= conv_data -> startframe && conv_data -> response_code == 200 && conv_data -> request_method && strncmp ( conv_data -> request_method , "CONNECT" , 7 ) == 0 && conv_data -> request_uri )  while ( tvb_reported_length_remaining ( tvb , offset ) != 0 )  len = dissect_http_message ( tvb , offset , pinfo , tree , conv_data ); if ( len == - 1 )  offset += len; static dissect_http_message(tvbuff_t *tvb, int offset, packet_info proto_tree *tree, http_conv_t *conv_data) proto_tree * http_tree = NULL ; const guchar * line ; gint next_offset ; const guchar * linep , * lineend ; int first_linelen , linelen ; gboolean is_request_or_reply ; guchar c ; http_type_t http_type ; ReqRespDissector reqresp_dissector ; headers_t headers ; int datalen ; int reported_datalen = - 1 ; first_linelen = tvb_find_line_end ( tvb , offset , tvb_ensure_length_remaining ( tvb , offset ) , & next_offset , FALSE ); line = tvb_get_ptr ( tvb , offset , first_linelen ); http_type = HTTP_OTHERS; is_request_or_reply = is_http_request_or_reply ( ( const gchar * ) line , first_linelen , & http_type , NULL , conv_data ); static is_http_request_or_reply(const gchar *data, int linelen, http_type_t ReqRespDissector http_conv_t *conv_data) int isHttpRequestOrReply = FALSE ; if ( linelen >= 2 && strncmp ( data , "M-" , 2 ) == 0 )  data += 2; linelen -= 2; if ( linelen >= 5 && strncmp ( data , "HTTP/" , 5 ) == 0 )  isHttpRequestOrReply = TRUE; const guchar * ptr = ( const guchar * ) data ; int indx = 0 ; while ( indx < linelen )  if ( * ptr == ' ' )  ptr ++; indx ++; switch ( indx )  if ( strncmp ( data , "GET" , indx ) == 0 || strncmp ( data , "PUT" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "ICY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "COPY" , indx ) == 0 || strncmp ( data , "HEAD" , indx ) == 0 || strncmp ( data , "LOCK" , indx ) == 0 || strncmp ( data , "MOVE" , indx ) == 0 || strncmp ( data , "POLL" , indx ) == 0 || strncmp ( data , "POST" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BCOPY" , indx ) == 0 || strncmp ( data , "BMOVE" , indx ) == 0 || strncmp ( data , "MKCOL" , indx ) == 0 || strncmp ( data , "TRACE" , indx ) == 0 || strncmp ( data , "LABEL" , indx ) == 0 || strncmp ( data , "MERGE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "DELETE" , indx ) == 0 || strncmp ( data , "SEARCH" , indx ) == 0 || strncmp ( data , "UNLOCK" , indx ) == 0 || strncmp ( data , "REPORT" , indx ) == 0 || strncmp ( data , "UPDATE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "NOTIFY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BDELETE" , indx ) == 0 || strncmp ( data , "CONNECT" , indx ) == 0 || strncmp ( data , "OPTIONS" , indx ) == 0 || strncmp ( data , "CHECKIN" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "PROPFIND" , indx ) == 0 || strncmp ( data , "CHECKOUT" , indx ) == 0 || strncmp ( data , "CCM_POST" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "SUBSCRIBE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "PROPPATCH" , indx ) == 0 || strncmp ( data , "BPROPFIND" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BPROPPATCH" , indx ) == 0 || strncmp ( data , "UNCHECKOUT" , indx ) == 0 || strncmp ( data , "MKACTIVITY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "MKWORKSPACE" , indx ) == 0 || strncmp ( data , "RPC_CONNECT" , indx ) == 0 || strncmp ( data , "RPC_IN_DATA" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "UNSUBSCRIBE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "RPC_OUT_DATA" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "VERSION-CONTROL" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BASELINE-CONTROL" , indx ) == 0 )  isHttpRequestOrReply = TRUE; return isHttpRequestOrReply ; if ( is_request_or_reply )  if ( ! req_resp_hdrs_do_reassembly ( tvb , offset , pinfo , http_desegment_headers , http_desegment_body ) )  stat_info = ep_alloc ( sizeof ( http_info_value_t ) ); stat_info -> framenum = pinfo -> fd -> num; stat_info -> response_code = 0; stat_info -> request_method = NULL; stat_info -> request_uri = NULL; stat_info -> http_host = NULL; if ( check_col ( pinfo -> cinfo , COL_INFO ) )  if ( is_request_or_reply )  line = tvb_get_ptr ( tvb , offset , first_linelen ); if ( tree )  ti = proto_tree_add_item ( tree , proto_http , tvb , offset , - 1 , ENC_NA ); http_tree = proto_item_add_subtree ( ti , ett_http ); http_type = HTTP_OTHERS; headers . content_type = NULL; headers . content_type_parameters = NULL; headers . have_content_length = FALSE; headers . content_length = 0; headers . content_encoding = NULL; headers . transfer_encoding = NULL; while ( tvb_reported_length_remaining ( tvb , offset ) != 0 )  linelen = tvb_find_line_end ( tvb , offset , tvb_ensure_length_remaining ( tvb , offset ) , & next_offset , FALSE ); if ( linelen < 0 )  line = tvb_get_ptr ( tvb , offset , linelen ); lineend = line + linelen; reqresp_dissector = NULL; is_request_or_reply = is_http_request_or_reply ( ( const gchar * ) line , linelen , & http_type , & reqresp_dissector , conv_data ); static is_http_request_or_reply(const gchar *data, int linelen, http_type_t ReqRespDissector http_conv_t *conv_data) int isHttpRequestOrReply = FALSE ; if ( linelen >= 2 && strncmp ( data , "M-" , 2 ) == 0 )  data += 2; linelen -= 2; if ( linelen >= 5 && strncmp ( data , "HTTP/" , 5 ) == 0 )  isHttpRequestOrReply = TRUE; const guchar * ptr = ( const guchar * ) data ; int indx = 0 ; while ( indx < linelen )  if ( * ptr == ' ' )  ptr ++; indx ++; switch ( indx )  if ( strncmp ( data , "GET" , indx ) == 0 || strncmp ( data , "PUT" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "ICY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "COPY" , indx ) == 0 || strncmp ( data , "HEAD" , indx ) == 0 || strncmp ( data , "LOCK" , indx ) == 0 || strncmp ( data , "MOVE" , indx ) == 0 || strncmp ( data , "POLL" , indx ) == 0 || strncmp ( data , "POST" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BCOPY" , indx ) == 0 || strncmp ( data , "BMOVE" , indx ) == 0 || strncmp ( data , "MKCOL" , indx ) == 0 || strncmp ( data , "TRACE" , indx ) == 0 || strncmp ( data , "LABEL" , indx ) == 0 || strncmp ( data , "MERGE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "DELETE" , indx ) == 0 || strncmp ( data , "SEARCH" , indx ) == 0 || strncmp ( data , "UNLOCK" , indx ) == 0 || strncmp ( data , "REPORT" , indx ) == 0 || strncmp ( data , "UPDATE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "NOTIFY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BDELETE" , indx ) == 0 || strncmp ( data , "CONNECT" , indx ) == 0 || strncmp ( data , "OPTIONS" , indx ) == 0 || strncmp ( data , "CHECKIN" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "PROPFIND" , indx ) == 0 || strncmp ( data , "CHECKOUT" , indx ) == 0 || strncmp ( data , "CCM_POST" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "SUBSCRIBE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "PROPPATCH" , indx ) == 0 || strncmp ( data , "BPROPFIND" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BPROPPATCH" , indx ) == 0 || strncmp ( data , "UNCHECKOUT" , indx ) == 0 || strncmp ( data , "MKACTIVITY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "MKWORKSPACE" , indx ) == 0 || strncmp ( data , "RPC_CONNECT" , indx ) == 0 || strncmp ( data , "RPC_IN_DATA" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "UNSUBSCRIBE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "RPC_OUT_DATA" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "VERSION-CONTROL" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BASELINE-CONTROL" , indx ) == 0 )  isHttpRequestOrReply = TRUE; return isHttpRequestOrReply ; if ( is_request_or_reply )  if ( linelen == 0 )  linep = line; while ( linep < lineend )  c = * linep ++; if ( ! isascii ( c ) )  if ( iscntrl ( c ) )  switch ( c )  if ( linelen == 0 )  offset = next_offset; offset = next_offset; datalen = tvb_length_remaining ( tvb , offset ); if ( headers . have_content_length && headers . content_length != - 1 && headers . transfer_encoding == NULL )  if ( datalen > headers . content_length )  datalen = ( int ) headers . content_length; reported_datalen = tvb_reported_length_remaining ( tvb , offset ); if ( reported_datalen > headers . content_length )  reported_datalen = ( int ) headers . content_length; switch ( http_type )  if ( headers . transfer_encoding == NULL )  datalen = 0; reported_datalen = - 1; if ( ( stat_info -> response_code / 100 ) == 1 || stat_info -> response_code == 204 || stat_info -> response_code == 304 )  datalen = 0; reported_datalen = - 1; reported_datalen = - 1; if ( datalen > 0 )  tvbuff_t * next_tvb ; next_tvb = tvb_new_subset ( tvb , offset , datalen , reported_datalen ); if ( conv_data -> upgrade != NULL && g_ascii_strcasecmp ( conv_data -> upgrade , "WebSocket" ) == 0 )  if ( headers . transfer_encoding != NULL && g_ascii_strcasecmp ( headers . transfer_encoding , "identity" ) != 0 )  if ( http_dechunk_body && ( g_ascii_strncasecmp ( headers . transfer_encoding , "chunked" , 7 ) == 0 ) )  chunks_decoded = chunked_encoding_dissector ( & next_tvb , pinfo , http_tree , 0 ); static chunked_encoding_dissector(tvbuff_t **tvb_ptr, packet_info proto_tree *tree, int offset) gint chunk_offset = 0 ; if ( tvb_ptr == NULL || * tvb_ptr == NULL )  tvb = * tvb_ptr; datalen = tvb_reported_length_remaining ( tvb , offset ); while ( datalen != 0 )  linelen = tvb_find_line_end ( tvb , offset , - 1 , & chunk_offset , TRUE ); if ( linelen <= 0 )  chunk_string = tvb_get_ephemeral_string ( tvb , offset , linelen ); if ( chunk_string == NULL )  c = ( gchar * ) chunk_string; if ( c = strchr ( c , ';' ) )  * c = '\0'; chunk_size = strtol ( ( gchar * ) chunk_string , NULL , 16 ); if ( chunk_size > datalen )  chunk_size = datalen; offset = chunk_offset + chunk_size + 2; datalen = tvb_reported_length_remaining ( tvb , offset ); 