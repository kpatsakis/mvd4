int udp_sendpage(struct sock *sk, struct page *page, int size_t size, int flags) struct udp_sock * up = udp_sk ( sk ) ; int ret ; if ( ! up -> pending )  struct msghdr msg = . msg_flags = flags | MSG_MORE ret = udp_sendmsg ( NULL , sk , & msg , 0 ); int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr size_t len) struct inet_sock * inet = inet_sk ( sk ) ; struct udp_sock * up = udp_sk ( sk ) ; struct ipcm_cookie ipc ; __be16 dport ; struct ip_options_data opt_copy ; if ( len > 0xFFFF )  if ( msg -> msg_flags & MSG_OOB )  ipc . opt = NULL; ipc . tx_flags = 0; if ( up -> pending )  if ( likely ( up -> pending ) )  if ( msg -> msg_name )  struct sockaddr_in * usin = ( struct sockaddr_in * ) msg -> msg_name ; if ( msg -> msg_namelen < sizeof ( * usin ) )  if ( usin -> sin_family != AF_INET )  if ( usin -> sin_family != AF_UNSPEC )  dport = usin -> sin_port; if ( dport == 0 )  if ( sk -> sk_state != TCP_ESTABLISHED )  ipc . addr = inet -> inet_saddr; ipc . oif = sk -> sk_bound_dev_if; if ( msg -> msg_controllen )  err = ip_cmsg_send ( sock_net ( sk ) , msg , & ipc ); if ( err )  if ( ! ipc . opt )  struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference ( inet -> inet_opt ); if ( inet_opt )  memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ); ipc . opt = & opt_copy . opt; saddr = ipc . addr; ipc . addr = faddr = daddr; if ( ipc . opt && ipc . opt -> opt . srr )  faddr = ipc . opt -> opt . faddr; if ( sock_flag ( sk , SOCK_LOCALROUTE ) || ( msg -> msg_flags & MSG_DONTROUTE ) || ( ipc . opt && ipc . opt -> opt . is_strictroute ) )  if ( ! ipc . oif )  ipc . oif = inet -> mc_index; if ( ! saddr )  if ( ! ipc . oif )  ipc . oif = inet -> uc_index; flowi4_init_output ( fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | FLOWI_FLAG_CAN_SLEEP , faddr , saddr , dport , inet -> inet_sport ); if ( ! ipc . addr )  daddr = ipc . addr = fl4 -> daddr; skb = ip_make_skb ( sk , fl4 , getfrag , msg -> msg_iov , ulen , sizeof ( struct udphdr ) , & ipc , & rt , msg -> msg_flags ); err = PTR_ERR ( skb ); if ( ! IS_ERR_OR_NULL ( skb ) )  err = udp_send_skb ( skb , fl4 ); static int udp_send_skb(struct sk_buff *skb, struct flowi4 *fl4) struct sock * sk = skb -> sk ; struct inet_sock * inet = inet_sk ( sk ) ; int is_udplite = IS_UDPLITE ( sk ) ; int offset = skb_transport_offset ( skb ) ; int len = skb -> len - offset ; uh = udp_hdr ( skb ); uh -> source = inet -> inet_sport; uh -> dest = fl4 -> fl4_dport; uh -> len = htons ( len ); uh -> check = 0; if ( is_udplite )  csum = udplite_csum ( skb ); if ( sk -> sk_no_check == UDP_CSUM_NOXMIT )  skb -> ip_summed = CHECKSUM_NONE; if ( skb -> ip_summed == CHECKSUM_PARTIAL )  udp4_hwcsum ( skb , fl4 -> saddr , fl4 -> daddr ); static void udp4_hwcsum(struct sk_buff *skb, __be32 src, __be32 dst) struct udphdr * uh = udp_hdr ( skb ) ; struct sk_buff * frags = skb_shinfo ( skb ) -> frag_list ; int offset = skb_transport_offset ( skb ) ; int len = skb -> len - offset ; int hlen = len ; if ( ! frags )  skb -> csum_start = skb_transport_header ( skb ) - skb -> head; skb -> csum_offset = offsetof ( struct udphdr , check ) uh -> check = ~csum_tcpudp_magic ( src , dst , len , IPPROTO_UDP , 0 ); csum = csum_add ( csum , frags -> csum ); hlen -= frags -> len; while ( frags = frags -> next )  csum = skb_checksum ( skb , offset , hlen , csum ); skb -> ip_summed = CHECKSUM_NONE; uh -> check = csum_tcpudp_magic ( src , dst , len , IPPROTO_UDP , csum ); if ( uh -> check == 0 )  uh -> check = CSUM_MANGLED_0; csum = udp_csum ( skb ); uh -> check = csum_tcpudp_magic ( fl4 -> saddr , fl4 -> daddr , len , sk -> sk_protocol , csum ); if ( uh -> check == 0 )  uh -> check = CSUM_MANGLED_0; err = ip_send_skb ( sock_net ( sk ) , skb ); if ( err )  if ( err == - ENOBUFS && ! inet -> recverr )  UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ); UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_OUTDATAGRAMS , is_udplite ); return err ; fl4 -> daddr = daddr; fl4 -> saddr = saddr; fl4 -> fl4_dport = dport; fl4 -> fl4_sport = inet -> inet_sport; err = ip_append_data ( sk , fl4 , getfrag , msg -> msg_iov , ulen , sizeof ( struct udphdr ) , & ipc , & rt , corkreq ? msg -> msg_flags | MSG_MORE : msg -> msg_flags ); if ( err )  kfree ( ipc . opt ); if ( ! err )  if ( err == - ENOBUFS || test_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) )  return err ; 