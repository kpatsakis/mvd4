static ssize_t ffs_ep0_write(struct file *file, const char __user size_t len, loff_t *ptr) struct ffs_data * ffs = file -> private_data ; ssize_t ret ; char * data ; if ( ffs_setup_state_clear_cancelled ( ffs ) == FFS_SETUP_CANCELLED )  static inline enum ffs_setup_state_clear_cancelled(struct ffs_data *ffs) return ( enum ffs_setup_state ) cmpxchg ( & ffs -> setup_state , FFS_SETUP_CANCELLED , FFS_NO_SETUP ) ; ret = ffs_mutex_lock ( & ffs -> mutex , file -> f_flags & O_NONBLOCK ); static int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock) return nonblock ? likely ( mutex_trylock ( mutex ) ) ? 0 : - EAGAIN : mutex_lock_interruptible ( mutex ) ; if ( unlikely ( ret < 0 ) )  switch ( ffs -> state )  if ( unlikely ( len < 16 ) )  data = ffs_prepare_buffer ( buf , len ); static char *ffs_prepare_buffer(const char __user *buf, size_t len) char * data ; if ( unlikely ( ! len ) )  return NULL ; data = kmalloc ( len , GFP_KERNEL ); if ( unlikely ( ! data ) )  return ERR_PTR ( - ENOMEM ) ; if ( unlikely ( __copy_from_user ( data , buf , len ) ) )  return ERR_PTR ( - EFAULT ) ; return data ; if ( IS_ERR ( data ) )  if ( ffs -> state == FFS_READ_DESCRIPTORS )  ret = __ffs_data_got_strings ( ffs , data , len ); if ( unlikely ( ret < 0 ) )  ret = ffs_epfiles_create ( ffs ); static int ffs_epfiles_create(struct ffs_data *ffs) struct ffs_epfile * epfile , * epfiles ; unsigned i , count ; count = ffs -> eps_count; epfiles = kcalloc ( count , sizeof ( * epfiles ) , GFP_KERNEL ); if ( ! epfiles )  epfile = epfiles; for (i = 1; i <= count; ++i, ++epfile) epfile -> ffs = ffs; if ( ffs -> user_flags & FUNCTIONFS_VIRTUAL_ADDR )  sprintf ( epfile -> name , "ep%02x" , ffs -> eps_addrmap [ i ] ); sprintf ( epfile -> name , "ep%u" , i ); epfile -> dentry = ffs_sb_create_file ( ffs -> sb , epfile -> name , epfile , & ffs_epfile_operations ); static struct dentry *ffs_sb_create_file(struct super_block const char *name, void const struct file_operations *fops) struct ffs_data * ffs = sb -> s_fs_info ; dentry = d_alloc_name ( sb -> s_root , name ); if ( unlikely ( ! dentry ) )  inode = ffs_sb_make_inode ( sb , data , fops , NULL , & ffs -> file_perms ); static struct inode ffs_sb_make_inode(struct super_block *sb, void const struct file_operations const struct inode_operations struct ffs_file_perms *perms) inode = new_inode ( sb ); if ( likely ( inode ) )  inode -> i_ino = get_next_ino ( ); inode -> i_mode = perms -> mode; inode -> i_uid = perms -> uid; inode -> i_gid = perms -> gid; inode -> i_atime = current_time; inode -> i_mtime = current_time; inode -> i_ctime = current_time; inode -> i_private = data; if ( fops )  inode -> i_fop = fops; if ( iops )  inode -> i_op = iops; return inode ; if ( unlikely ( ! inode ) )  dput ( dentry ); d_add ( dentry , inode ); return dentry ; if ( unlikely ( ! epfile -> dentry ) )  