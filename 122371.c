static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg) struct ppp_file * pf = file -> private_data ; if ( ! pf )  return ppp_unattached_ioctl ( current -> nsproxy -> net_ns , pf , file , cmd , arg ) ; static int ppp_unattached_ioctl(struct net *net, struct ppp_file struct file *file, unsigned int cmd, unsigned long arg) int unit , err = - EFAULT ; struct ppp * ppp ; int __user * p = ( int __user * ) arg ; switch ( cmd )  if ( get_user ( unit , p ) )  ppp = ppp_create_interface ( net , unit , file , & err ); static struct ppp *ppp_create_interface(struct net *net, int struct file *file, int *retp) struct ppp * ppp ; struct ppp_net * pn ; int i ; dev = alloc_netdev ( sizeof ( struct ppp ) , "" , NET_NAME_UNKNOWN , ppp_setup ); if ( ! dev )  pn = ppp_pernet ( net ); static inline struct ppp_net *ppp_pernet(struct net *net) return net_generic ( net , ppp_net_id ) ; ppp = netdev_priv ( dev ); ppp -> dev = dev; ppp -> mru = PPP_MRU; ppp -> file . hdrlen = PPP_HDRLEN - 2; ppp -> owner = file; for (i = 0; i < NUM_NP; ++i) ppp -> npmode [ i ] = NPMODE_PASS; ppp -> minseq = - 1; ppp -> pass_filter = NULL; ppp -> active_filter = NULL; if ( unit < 0 )  unit = unit_get ( & pn -> units_idr , ppp ); static int unit_get(struct idr *p, void *ptr) return idr_alloc ( p , ptr , 0 , 0 , GFP_KERNEL ) ; if ( unit < 0 )  if ( unit_find ( & pn -> units_idr , unit ) )  static void *unit_find(struct idr *p, int n) return idr_find ( p , n ) ; unit = unit_set ( & pn -> units_idr , ppp , unit ); static int unit_set(struct idr *p, void *ptr, int n) int unit ; unit = idr_alloc ( p , ptr , n , n + 1 , GFP_KERNEL ); if ( unit == - ENOSPC )  unit = - EINVAL; return unit ; if ( unit < 0 )  sprintf ( dev -> name , "ppp%d" , unit ); ret = register_netdevice ( dev ); if ( ret != 0 )  netdev_err ( ppp -> dev , "PPP: couldn't register device %s (%d)\n" , dev -> name , ret ); * retp = ret; 