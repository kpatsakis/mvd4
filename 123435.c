XML_Parser XML_ExternalEntityParserCreate(XML_Parser const XML_Char const XML_Char *encodingName) XML_Parser parser = oldParser ; DTD * newDtd = NULL ; DTD * oldDtd = _dtd ; if ( ! context )  newDtd = oldDtd; if ( ns )  XML_Char tmp [ 2 ] ; * tmp = namespaceSeparator; parser = parserCreate ( encodingName , & parser -> m_mem , tmp , newDtd ); parser = parserCreate ( encodingName , & parser -> m_mem , NULL , newDtd ); if ( ! parser )  if ( context )  if ( ! dtdCopy ( _dtd , oldDtd , & parser -> m_mem ) || ! setContext ( parser , context ) )  static setContext(XML_Parser parser, const XML_Char *context) DTD * const dtd = _dtd const XML_Char * s = context ; while ( * context != XML_T ( '\0' ) )  if ( * s == CONTEXT_SEP || * s == XML_T ( '\0' ) )  if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )  if ( * s != XML_T ( '\0' ) )  s ++; context = s; if ( * s == XML_T ( '=' ) )  PREFIX * prefix ; if ( poolLength ( & tempPool ) == 0 )  prefix = & dtd -> defaultPrefix; if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )  prefix = ( PREFIX * ) lookup ( & dtd -> prefixes , poolStart ( & tempPool ) , sizeof ( PREFIX ) ); if ( ! prefix )  if ( prefix -> name == poolStart ( & tempPool ) )  prefix -> name = poolCopyString ( & dtd -> pool , prefix -> name ); if ( ! prefix -> name )  for (context = s + *context != CONTEXT_SEP && *context != context++) if ( ! poolAppendChar ( & tempPool , * context ) )  if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )  if ( addBinding ( parser , prefix , NULL , poolStart ( & tempPool ) , & inheritedBindings ) != XML_ERROR_NONE )  s = context; if ( ! poolAppendChar ( & tempPool , * s ) )  s ++; static NAMED lookup(HASH_TABLE *table, KEY name, size_t createSize) if ( table -> size == 0 )  size_t tsize ; if ( ! createSize )  table -> power = INIT_POWER; table -> size = ( size_t ) 1 << INIT_POWER; tsize = table -> size * sizeof ( NAMED * ); table -> v = ( NAMED * * ) table -> mem -> malloc_fcn ( tsize ); if ( ! table -> v )  memset ( table -> v , 0 , tsize ); i = hash ( name ) & ( ( unsigned long ) table -> size - 1 ); table -> v [ i ] = ( NAMED * ) table -> mem -> malloc_fcn ( createSize ); if ( ! table -> v [ i ] )  memset ( table -> v [ i ] , 0 , createSize ); table -> v [ i ] -> name = name; ( table -> used ) ++; return table -> v [ i ] ; 