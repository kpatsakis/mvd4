static void sysbus_esp_mem_write(void *opaque, hwaddr uint64_t val, unsigned int size) SysBusESPState * sysbus = opaque ; uint32_t saddr ; saddr = addr >> sysbus -> it_shift; esp_reg_write ( & sysbus -> esp , saddr , val ); void esp_reg_write(ESPState *s, uint32_t saddr, uint64_t val) switch ( saddr )  s -> tchi_written = true; s -> rregs [ ESP_RSTAT ] &= ~STAT_TC; if ( s -> do_cmd )  if ( s -> ti_size == TI_BUFSZ - 1 )  s -> ti_size ++; s -> ti_buf [ s -> ti_wptr ++ ] = val & 0xff; s -> rregs [ saddr ] = val; if ( val & CMD_DMA )  s -> dma = 1; s -> rregs [ ESP_TCLO ] = s -> wregs [ ESP_TCLO ]; s -> rregs [ ESP_TCMID ] = s -> wregs [ ESP_TCMID ]; s -> rregs [ ESP_TCHI ] = s -> wregs [ ESP_TCHI ]; s -> dma = 0; switch ( val & CMD_CMD )  s -> rregs [ ESP_RINTR ] = INTR_FC; s -> rregs [ ESP_RSEQ ] = 0; s -> rregs [ ESP_RFLAGS ] = 0; s -> rregs [ ESP_RINTR ] = INTR_RST; s -> rregs [ ESP_RINTR ] = INTR_FC; s -> rregs [ ESP_RSTAT ] |= STAT_MI; s -> rregs [ ESP_RINTR ] = INTR_DC; s -> rregs [ ESP_RSEQ ] = 0; s -> rregs [ ESP_RFLAGS ] = 0; s -> rregs [ ESP_RSTAT ] = STAT_TC; s -> rregs [ ESP_RINTR ] = INTR_FC; s -> rregs [ ESP_RSEQ ] = 0; handle_satn_stop ( s ); static void handle_satn_stop(ESPState *s) if ( s -> dma && ! s -> dma_enabled )  s -> cmdlen = get_cmd ( s , s -> cmdbuf ); static uint32_t get_cmd(ESPState *s, uint8_t *buf) uint32_t dmalen ; if ( s -> dma )  dmalen = s -> ti_size; memcpy ( buf , s -> ti_buf , dmalen ); buf [ 0 ] = buf [ 2 ] >> 5; 