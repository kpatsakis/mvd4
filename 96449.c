static int CVE_2013_7011_PATCHED_read_header(FFV1Context *f) uint8_t state [ CONTEXT_SIZE ] ; int i , j , context_count = - 1 ; RangeCoder * const c = & f -> slice_context [ 0 ] -> c memset ( state , 128 , sizeof ( state ) ); if ( f -> version < 2 )  int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; unsigned v = get_symbol ( c , state , 0 ) ; if ( v >= 2 )  f -> version = v; f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); if ( f -> ac > 1 )  for (i = 1; i < 256; i++) f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; f -> colorspace = get_symbol ( c , state , 0 ); if ( f -> version > 0 )  f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); chroma_planes = get_rac ( c , state ); chroma_h_shift = get_symbol ( c , state , 0 ); chroma_v_shift = get_symbol ( c , state , 0 ); transparency = get_rac ( c , state ); if ( f -> plane_count )  if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency )  f -> chroma_planes = chroma_planes; f -> chroma_h_shift = chroma_h_shift; f -> chroma_v_shift = chroma_v_shift; f -> transparency = transparency; f -> plane_count = 2 + f -> transparency; if ( f -> colorspace == 0 )  if ( ! f -> transparency && ! f -> chroma_planes )  if ( f -> avctx -> bits_per_raw_sample <= 8 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; if ( f -> avctx -> bits_per_raw_sample == 9 )  f -> packed_at_lsb = 1; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; if ( f -> avctx -> bits_per_raw_sample == 10 )  f -> packed_at_lsb = 1; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; if ( f -> colorspace == 1 )  if ( f -> chroma_h_shift || f -> chroma_v_shift )  if ( f -> avctx -> bits_per_raw_sample == 9 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; if ( f -> avctx -> bits_per_raw_sample == 10 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; if ( f -> avctx -> bits_per_raw_sample == 12 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; if ( f -> avctx -> bits_per_raw_sample == 14 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; if ( f -> transparency )  f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; if ( f -> version < 2 )  context_count = read_quant_tables ( c , f -> quant_table ); if ( context_count < 0 )  if ( f -> version < 3 )  f -> slice_count = get_symbol ( c , state , 0 ); const uint8_t * p = c -> bytestream_end ; for (f->slice_count = f->slice_count < MAX_SLICES && 3 < p - f->slice_count++) int trailer = 3 + 5 * ! ! f -> ec ; int size = AV_RB24 ( p - trailer ) ; if ( size + trailer > p - c -> bytestream_start )  p -= size + trailer; if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  for (j = 0; j < f->slice_count; j++) FFV1Context * fs = f -> slice_context [ j ] ; fs -> ac = f -> ac; fs -> packed_at_lsb = f -> packed_at_lsb; fs -> slice_damaged = 0; if ( f -> version == 2 )  fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; fs -> slice_x /= f -> num_h_slices; fs -> slice_y /= f -> num_v_slices; fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  for (i = 0; i < f->plane_count; i++) PlaneContext * const p = & fs -> plane [ i ] if ( f -> version == 2 )  int idx = get_symbol ( c , state , 0 ) ; if ( idx > ( unsigned ) f -> quant_table_count )  p -> quant_table_index = idx; context_count = f -> context_count [ idx ]; memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); if ( f -> version <= 2 )  if ( p -> context_count < context_count )  av_freep ( & p -> state ); av_freep ( & p -> vlc_state ); p -> context_count = context_count; 