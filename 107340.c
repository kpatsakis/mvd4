static dissect_iax2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) proto_item * iax2_item ; proto_tree * iax2_tree ; guint32 offset = 0 , len ; guint16 scallno = 0 ; guint16 stmp ; packet_type type ; proto_item * full_mini_base ; iax2_item = proto_tree_add_item ( tree , proto_iax2 , tvb , offset , - 1 , ENC_NA ); iax2_tree = proto_item_add_subtree ( iax2_item , ett_iax2 ); stmp = tvb_get_ntohs ( tvb , offset ); if ( stmp == 0 )  offset += 2; stmp = tvb_get_ntohs ( tvb , offset ); if ( stmp & 0x8000 )  type = IAX2_MINI_VIDEO_PACKET; scallno = stmp & 0x7FFF; offset += 2; type = IAX2_TRUNK_PACKET; scallno = tvb_get_ntohs ( tvb , offset ); offset += 2; if ( scallno & 0x8000 )  type = IAX2_FULL_PACKET; type = IAX2_MINI_VOICE_PACKET; scallno &= 0x7FFF; full_mini_base = proto_tree_add_uint ( iax2_tree , hf_iax2_packet_type , tvb , 0 , offset , type ); full_mini_subtree = proto_item_add_subtree ( full_mini_base , ett_iax2_full_mini_subtree ); switch ( type )  len = dissect_fullpacket ( tvb , offset , scallno , pinfo , full_mini_subtree , tree ); static dissect_fullpacket(tvbuff_t *tvb, guint32 guint16 packet_info *pinfo, proto_tree proto_tree *main_tree) guint16 dcallno ; guint8 type ; guint8 csub ; iax_call_data * iax_call ; iax_packet_data * iax_packet ; dcallno = tvb_get_ntohs ( tvb , offset ) & 0x7FFF; type = tvb_get_guint8 ( tvb , offset + 8 ); csub = tvb_get_guint8 ( tvb , offset + 9 ); iax_packet = ( iax_packet_data * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 ); if ( ! iax_packet )  if ( type == AST_FRAME_IAX && csub == IAX_COMMAND_NEW )  iax_call = iax_lookup_call ( pinfo , scallno , dcallno , & reversed ); static iax_call_data *iax_lookup_call( packet_info guint32 guint32 gboolean *reversed_p) if ( dcallno != 0 )  guint dst_circuit_id ; dst_circuit_id = iax_circuit_lookup ( & pinfo -> dst , pinfo -> ptype , pinfo -> destport , dcallno ); static guint iax_circuit_lookup(const address port_type guint32 guint32 callno) iax_circuit_key key ; guint32 * circuit_id_p ; key . addr = * address_p; key . ptype = ptype; key . port = port; key . callno = callno; circuit_id_p = ( guint32 * ) g_hash_table_lookup ( iax_circuit_hashtab , & key ); if ( ! circuit_id_p )  iax_circuit_key * new_key ; new_key = wmem_new ( wmem_file_scope ( ) , iax_circuit_key ); new_key -> addr . type = address_p -> type; new_key -> addr . len = MIN ( address_p -> len , MAX_ADDRESS ); new_key -> addr . data = new_key -> address_data; memcpy ( new_key -> address_data , address_p -> data , new_key -> addr . len ); new_key -> ptype = ptype; new_key -> port = port; new_key -> callno = callno; g_hash_table_insert ( iax_circuit_hashtab , new_key , circuit_id_p ); g_debug ( "Created new circuit id %u for node %s" , * circuit_id_p , key_to_str ( new_key ) ); 