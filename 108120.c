 StructType::ConstructData(JSContext* HandleObject const CallArgs& args) if ( ! CType :: IsCType ( obj ) || CType :: GetTypeCode ( obj ) != TYPE_struct )  if ( ! CType :: IsSizeDefined ( obj ) )  JSObject * result = CData :: Create ( cx , obj , NullPtr ( ) , nullptr , true ) ; if ( ! result )  if ( args . length ( ) == 0 )  char * buffer = static_cast < char * > CData :: GetData ( result ) if ( args . length ( ) == 1 )  if ( ExplicitConvert ( cx , args [ 0 ] , obj , buffer ) )  static ExplicitConvert(JSContext* cx, HandleValue val, HandleObject targetType, void* buffer) if ( ImplicitConvert ( cx , val , targetType , buffer , false , nullptr ) )  static ImplicitConvert(JSContext* HandleValue JSObject* void* bool bool* freePointer) RootedObject targetType ( cx , targetType_ ) ; RootedObject valObj ( cx , nullptr ) ; if ( val . isObject ( ) )  valObj = & val . toObject ( ); if ( CData :: IsCData ( valObj ) )  if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  sourceData = valObj; sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; if ( ! p )  if ( CType :: TypesEqual ( sourceType , targetType ) )  memmove ( buffer , p -> cargs , p -> cargs_size ); 