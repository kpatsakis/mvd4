static void ide_atapi_cmd(IDEState *s) const uint8_t * packet ; uint8_t * buf ; int max_len ; packet = s -> io_buffer; buf = s -> io_buffer; if ( s -> sense_key == SENSE_UNIT_ATTENTION && s -> io_buffer [ 0 ] != GPCMD_REQUEST_SENSE && s -> io_buffer [ 0 ] != GPCMD_INQUIRY )  switch ( s -> io_buffer [ 0 ] )  int action , code ; if ( packet [ 0 ] == GPCMD_MODE_SENSE_10 )  max_len = ube16_to_cpu ( packet + 7 ); static inline int ube16_to_cpu(const uint8_t *buf) return ( buf [ 0 ] << 8 ) | buf [ 1 ] ; max_len = packet [ 4 ]; action = packet [ 2 ] >> 6; code = packet [ 2 ] & 0x3f; switch ( action )  switch ( code )  buf [ 2 ] = 0x70; buf [ 3 ] = 0; buf [ 4 ] = 0; buf [ 5 ] = 0; buf [ 6 ] = 0; buf [ 7 ] = 0; buf [ 8 ] = 0x01; buf [ 9 ] = 0x06; buf [ 10 ] = 0x00; buf [ 11 ] = 0x05; buf [ 12 ] = 0x00; buf [ 13 ] = 0x00; buf [ 14 ] = 0x00; buf [ 15 ] = 0x00; buf [ 2 ] = 0x70; buf [ 3 ] = 0; buf [ 4 ] = 0; buf [ 5 ] = 0; buf [ 6 ] = 0; buf [ 7 ] = 0; buf [ 8 ] = 0x2a; buf [ 9 ] = 0x12; buf [ 10 ] = 0x00; buf [ 11 ] = 0x00; buf [ 12 ] = 0x71; buf [ 13 ] = 3 << 5; buf [ 14 ] = ( 1 << 0 ) | ( 1 << 3 ) | ( 1 << 5 ); if ( bdrv_is_locked ( s -> bs ) )  buf [ 6 ] |= 1 << 1; buf [ 15 ] = 0x00; buf [ 18 ] = 0; buf [ 19 ] = 2; buf [ 24 ] = 0; buf [ 25 ] = 0; buf [ 26 ] = 0; buf [ 27 ] = 0; max_len = packet [ 4 ]; memset ( buf , 0 , 18 ); buf [ 0 ] = 0x70 | ( 1 << 7 ); buf [ 2 ] = s -> sense_key; buf [ 7 ] = 10; buf [ 12 ] = s -> asc; if ( s -> sense_key == SENSE_UNIT_ATTENTION )  s -> sense_key = SENSE_NONE; uint64_t total_sectors ; total_sectors >>= 2; max_len = ube16_to_cpu ( packet + 8 ); static inline int ube16_to_cpu(const uint8_t *buf) return ( buf [ 0 ] << 8 ) | buf [ 1 ] ; buf [ 2 ] = 0; buf [ 3 ] = 0; buf [ 4 ] = 0; buf [ 5 ] = 1; int format , msf , start_track , len ; uint64_t total_sectors ; total_sectors >>= 2; if ( total_sectors == 0 )  max_len = ube16_to_cpu ( packet + 7 ); static inline int ube16_to_cpu(const uint8_t *buf) return ( buf [ 0 ] << 8 ) | buf [ 1 ] ; format = packet [ 9 ] >> 6; switch ( format )  memset ( buf , 0 , 12 ); buf [ 1 ] = 0x0a; buf [ 2 ] = 0x01; buf [ 3 ] = 0x01; int format = packet [ 7 ] ; max_len = ube16_to_cpu ( packet + 8 ); static inline int ube16_to_cpu(const uint8_t *buf) return ( buf [ 0 ] << 8 ) | buf [ 1 ] ; if ( format < 0xff )  if ( media_is_cd ( s ) )  static inline int media_is_cd(IDEState *s) return ( media_present ( s ) && s -> nb_sectors <= CD_MAX_SECTORS ) ; static inline int media_present(IDEState *s) return ( s -> nb_sectors > 0 ) ; if ( ! media_present ( s ) )  static inline int media_present(IDEState *s) return ( s -> nb_sectors > 0 ) ; memset ( buf , 0 , max_len > IDE_DMA_BUF_SECTORS * 512 + 4 ? IDE_DMA_BUF_SECTORS * 512 + 4 : max_len ); max_len = packet [ 4 ]; buf [ 0 ] = 0x05; buf [ 1 ] = 0x80; buf [ 2 ] = 0x00; buf [ 3 ] = 0x21; buf [ 4 ] = 31; buf [ 5 ] = 0; buf [ 6 ] = 0; buf [ 7 ] = 0; if ( packet [ 2 ] != 0 || packet [ 3 ] != 0 )  max_len = ube16_to_cpu ( packet + 7 ); static inline int ube16_to_cpu(const uint8_t *buf) return ( buf [ 0 ] << 8 ) | buf [ 1 ] ; if ( max_len > 512 )  max_len = 512; memset ( buf , 0 , max_len ); cpu_to_ube16 ( buf + 6 , MMC_PROFILE_DVD_ROM ); static inline void cpu_to_ube16(uint8_t *buf, int val) buf [ 0 ] = val >> 8; buf [ 1 ] = val; cpu_to_ube16 ( buf + 6 , MMC_PROFILE_CD_ROM ); static inline void cpu_to_ube16(uint8_t *buf, int val) buf [ 0 ] = val >> 8; buf [ 1 ] = val; buf [ 10 ] = 0x02 | 0x01; len += ide_atapi_set_profile ( buf , & index , MMC_PROFILE_DVD_ROM ); static inline uint8_t ide_atapi_set_profile(uint8_t *buf, uint8_t uint16_t profile) uint8_t * buf_profile = buf + 12 ; buf_profile += ( ( * index ) * 4 ); cpu_to_ube16 ( buf_profile , profile ); static inline void cpu_to_ube16(uint8_t *buf, int val) buf [ 0 ] = val >> 8; buf [ 1 ] = val; buf_profile [ 2 ] = ( ( buf_profile [ 0 ] == buf [ 6 ] ) && ( buf_profile [ 1 ] == buf [ 7 ] ) ); ( * index ) ++; buf [ 11 ] += 4; len += ide_atapi_set_profile ( buf , & index , MMC_PROFILE_CD_ROM ); static inline uint8_t ide_atapi_set_profile(uint8_t *buf, uint8_t uint16_t profile) uint8_t * buf_profile = buf + 12 ; buf_profile += ( ( * index ) * 4 ); cpu_to_ube16 ( buf_profile , profile ); buf_profile [ 2 ] = ( ( buf_profile [ 0 ] == buf [ 6 ] ) && ( buf_profile [ 1 ] == buf [ 7 ] ) ); ( * index ) ++; buf [ 11 ] += 4; cpu_to_ube32 ( buf , len - 4 ); static inline void cpu_to_ube32(uint8_t *buf, unsigned int val) buf [ 0 ] = val >> 24; buf [ 1 ] = val >> 16; buf [ 2 ] = val >> 8; buf [ 3 ] = val; ide_atapi_cmd_reply ( s , len , max_len ); static void ide_atapi_cmd_reply(IDEState *s, int size, int max_size) if ( size > max_size )  size = max_size; s -> lba = - 1; s -> packet_transfer_size = size; s -> io_buffer_size = size; s -> elementary_transfer_size = 0; s -> io_buffer_index = 0; if ( s -> atapi_dma )  s -> status = READY_STAT | SEEK_STAT | DRQ_STAT; ide_dma_start ( s , ide_atapi_cmd_read_dma_cb ); static void ide_dma_start(IDEState *s, BlockDriverCompletionFunc *dma_cb) BMDMAState * bm = s -> bmdma ; if ( ! bm )  bm -> ide_if = s; bm -> dma_cb = dma_cb; bm -> cur_prd_last = 0; bm -> cur_prd_addr = 0; bm -> cur_prd_len = 0; bm -> sector_num = ide_get_sector ( s ); static int64_t ide_get_sector(IDEState *s) if ( s -> select & 0x40 )  if ( ! s -> lba48 )  sector_num = ( ( s -> select & 0x0f ) << 24 ) | ( s -> hcyl << 16 ) | ( s -> lcyl << 8 ) | s -> sector; sector_num = ( ( int64_t ) s -> hob_hcyl << 40 ) | ( ( int64_t ) s -> hob_lcyl << 32 ) | ( ( int64_t ) s -> hob_sector << 24 ) | ( ( int64_t ) s -> hcyl << 16 ) | ( ( int64_t ) s -> lcyl << 8 ) | s -> sector; sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 ); return sector_num ; bm -> nsector = s -> nsector; if ( bm -> status & BM_STATUS_DMAING )  bm -> dma_cb ( bm , 0 ); s -> status = READY_STAT | SEEK_STAT; ide_atapi_cmd_reply_end ( s ); static void ide_atapi_cmd_reply_end(IDEState *s) printf ( "reply: tx_size=%d elem_tx_size=%d index=%d\n" , s -> packet_transfer_size , s -> elementary_transfer_size , s -> io_buffer_index ); if ( s -> packet_transfer_size <= 0 )  ide_transfer_stop ( s ); static void ide_transfer_stop(IDEState *s) s -> end_transfer_func = ide_transfer_stop; s -> data_ptr = s -> io_buffer; s -> data_end = s -> io_buffer; s -> status &= ~DRQ_STAT; buffered_pio_reset ( s ); static inline buffered_pio_reset(IDEState *s) if ( ( unsigned ) s -> drive_serial - 1 < 2 )  if ( ( unsigned ) s -> drive_serial - 3 < 2 )  s -> status = READY_STAT | SEEK_STAT; s -> nsector = ( s -> nsector & ~7 ) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD; ide_set_irq ( s ); static inline void ide_set_irq(IDEState *s) BMDMAState * bm = s -> bmdma ; if ( ! s -> bs )  if ( ! ( s -> cmd & IDE_CMD_DISABLE_IRQ ) )  if ( bm )  bm -> status |= BM_STATUS_INT; qemu_irq_raise ( s -> irq ); printf ( "status=0x%x\n" , s -> status ); if ( s -> lba != - 1 && s -> io_buffer_index >= s -> cd_sector_size )  ret = cd_read_sector ( s -> bs , s -> lba , s -> io_buffer , s -> cd_sector_size ); static int cd_read_sector(BlockDriverState *bs, int lba, uint8_t int sector_size) switch ( sector_size )  ret = bdrv_read ( bs , ( int64_t ) lba << 2 , buf , 4 ); ret = bdrv_read ( bs , ( int64_t ) lba << 2 , buf + 16 , 4 ); if ( ret < 0 )  return ret ; cd_data_to_raw ( buf , lba ); static void cd_data_to_raw(uint8_t *buf, int lba) buf [ 0 ] = 0x00; memset ( buf + 1 , 0xff , 10 ); buf [ 11 ] = 0x00; buf += 12; lba_to_msf ( buf , lba ); static void lba_to_msf(uint8_t *buf, int lba) lba += 150; buf [ 0 ] = ( lba / 75 ) / 60; buf [ 1 ] = ( lba / 75 ) % 60; buf [ 2 ] = lba % 75; buf [ 3 ] = 0x01; buf += 4; buf += 2048; memset ( buf , 0 , 288 ); return ret ; if ( ret < 0 )  ide_transfer_stop ( s ); static void ide_transfer_stop(IDEState *s) s -> end_transfer_func = ide_transfer_stop; s -> data_ptr = s -> io_buffer; s -> data_end = s -> io_buffer; s -> status &= ~DRQ_STAT; buffered_pio_reset ( s ); ide_atapi_io_error ( s , ret ); static void ide_atapi_io_error(IDEState *s, int ret) if ( ret == - ENOMEDIUM )  ide_atapi_cmd_error ( s , SENSE_NOT_READY , ASC_MEDIUM_NOT_PRESENT ); static void ide_atapi_cmd_error(IDEState *s, int sense_key, int asc) printf ( "atapi_cmd_error: sense=0x%x asc=0x%x\n" , sense_key , asc ); s -> error = sense_key << 4; s -> status = READY_STAT | ERR_STAT; s -> nsector = ( s -> nsector & ~7 ) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD; s -> sense_key = sense_key; s -> asc = asc; ide_set_irq ( s ); static inline void ide_set_irq(IDEState *s) BMDMAState * bm = s -> bmdma ; if ( ! s -> bs )  if ( ! ( s -> cmd & IDE_CMD_DISABLE_IRQ ) )  if ( bm )  bm -> status |= BM_STATUS_INT; qemu_irq_raise ( s -> irq ); ide_atapi_cmd_error ( s , SENSE_ILLEGAL_REQUEST , ASC_LOGICAL_BLOCK_OOR ); static void ide_atapi_cmd_error(IDEState *s, int sense_key, int asc) printf ( "atapi_cmd_error: sense=0x%x asc=0x%x\n" , sense_key , asc ); s -> error = sense_key << 4; s -> status = READY_STAT | ERR_STAT; s -> nsector = ( s -> nsector & ~7 ) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD; s -> sense_key = sense_key; s -> asc = asc; ide_set_irq ( s ); s -> lba ++; s -> io_buffer_index = 0; if ( s -> elementary_transfer_size > 0 )  size = s -> cd_sector_size - s -> io_buffer_index; if ( size > s -> elementary_transfer_size )  size = s -> elementary_transfer_size; ide_transfer_start ( s , s -> io_buffer + s -> io_buffer_index , size , ide_atapi_cmd_reply_end ); static void ide_transfer_start(IDEState *s, uint8_t *buf, int EndTransferFunc *end_transfer_func) s -> end_transfer_func = end_transfer_func; s -> data_ptr = buf; s -> data_end = buf + size; if ( ! ( s -> status & ERR_STAT ) )  s -> status |= DRQ_STAT; buffered_pio_reset ( s ); static inline buffered_pio_reset(IDEState *s) if ( ( unsigned ) s -> drive_serial - 1 < 2 )  if ( ( unsigned ) s -> drive_serial - 3 < 2 )  s -> packet_transfer_size -= size; s -> elementary_transfer_size -= size; s -> io_buffer_index += size; s -> nsector = ( s -> nsector & ~7 ) | ATAPI_INT_REASON_IO; byte_count_limit = s -> lcyl | ( s -> hcyl << 8 ); printf ( "byte_count_limit=%d\n" , byte_count_limit ); if ( byte_count_limit == 0xffff )  byte_count_limit --; size = s -> packet_transfer_size; if ( size > byte_count_limit )  if ( byte_count_limit & 1 )  byte_count_limit --; size = byte_count_limit; s -> lcyl = size; s -> hcyl = size >> 8; s -> elementary_transfer_size = size; if ( s -> lba != - 1 )  if ( size > ( s -> cd_sector_size - s -> io_buffer_index ) )  size = ( s -> cd_sector_size - s -> io_buffer_index ); ide_transfer_start ( s , s -> io_buffer + s -> io_buffer_index , size , ide_atapi_cmd_reply_end ); static void ide_transfer_start(IDEState *s, uint8_t *buf, int EndTransferFunc *end_transfer_func) s -> end_transfer_func = end_transfer_func; s -> data_ptr = buf; s -> data_end = buf + size; if ( ! ( s -> status & ERR_STAT ) )  s -> status |= DRQ_STAT; buffered_pio_reset ( s ); s -> packet_transfer_size -= size; s -> elementary_transfer_size -= size; s -> io_buffer_index += size; ide_set_irq ( s ); static inline void ide_set_irq(IDEState *s) BMDMAState * bm = s -> bmdma ; if ( ! s -> bs )  if ( ! ( s -> cmd & IDE_CMD_DISABLE_IRQ ) )  if ( bm )  bm -> status |= BM_STATUS_INT; qemu_irq_raise ( s -> irq ); printf ( "status=0x%x\n" , s -> status ); 