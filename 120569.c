ram_addr_t qemu_ram_alloc(ram_addr_t size, MemoryRegion *mr) return qemu_ram_alloc_from_ptr ( size , NULL , mr ) ; ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void MemoryRegion *mr) RAMBlock * block , * new_block ; size = TARGET_PAGE_ALIGN ( size ); new_block = g_malloc0 ( sizeof ( * new_block ) ); if ( host )  if ( mem_path )  new_block -> host = file_ram_alloc ( new_block , size , mem_path ); static void *file_ram_alloc(RAMBlock ram_addr_t const char *path) char * filename ; char * sanitized_name ; void * area ; int fd ; int flags ; unsigned long hpagesize ; hpagesize = gethugepagesize ( path ); static long gethugepagesize(const char *path) struct statfs fs ; int ret ; ret = statfs ( path , & fs ); while ( ret != 0 && errno == EINTR )  if ( ret != 0 )  return 0 ; return fs . f_bsize ; if ( ! hpagesize )  if ( memory < hpagesize )  if ( kvm_enabled ( ) && ! kvm_has_sync_mmu ( ) )  sanitized_name = g_strdup ( block -> mr -> name ); filename = g_strdup_printf ( "%s/qemu_back_mem.%s.XXXXXX" , path , sanitized_name ); fd = mkstemp ( filename ); if ( fd < 0 )  memory = ( memory + hpagesize - 1 ) & ~ ( hpagesize - 1 ); flags = mem_prealloc ? MAP_POPULATE | MAP_SHARED : MAP_PRIVATE; area = mmap ( 0 , memory , PROT_READ | PROT_WRITE , flags , fd , 0 ); if ( area == MAP_FAILED )  close ( fd ); 