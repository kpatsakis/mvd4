 proto_register_field_array(const int parent, hf_register_info *hf, const int num_records) hf_register_info * ptr = hf ; protocol_t * proto ; int i ; proto = find_protocol_by_id ( parent ); protocol_t find_protocol_by_id(const int proto_id) header_field_info * hfinfo ; if ( proto_id < 0 )  return NULL ; return ( protocol_t * ) hfinfo -> strings ; for (i = 0; i < num_records; i++, ptr++) if ( * ptr -> p_id != - 1 && * ptr -> p_id != 0 )  fprintf ( stderr , "Duplicate field detected in call to proto_register_field_array: %s is already registered\n" , ptr -> hfinfo . abbrev ); * ptr -> p_id = proto_register_field_common ( proto , & ptr -> hfinfo , parent ); static proto_register_field_common(protocol_t *proto, header_field_info *hfi, const int parent) if ( proto != NULL )  g_ptr_array_add ( proto -> fields , hfi ); return proto_register_field_init ( hfi , parent ) ; static proto_register_field_init(header_field_info *hfinfo, const int parent) tmp_fld_check_assert ( hfinfo ); static tmp_fld_check_assert(header_field_info *hfinfo) if ( ! hfinfo -> name || ! hfinfo -> name [ 0 ] )  if ( hfinfo -> abbrev )  g_error ( "Field (abbrev='%s') does not have a name\n" , hfinfo -> abbrev ); if ( ! hfinfo -> abbrev || ! hfinfo -> abbrev [ 0 ] )  g_error ( "Field '%s' does not have an abbreviation\n" , hfinfo -> name ); if ( hfinfo -> strings != NULL && ! ( ( hfinfo -> type == FT_UINT8 ) || ( hfinfo -> type == FT_UINT16 ) || ( hfinfo -> type == FT_UINT24 ) || ( hfinfo -> type == FT_UINT32 ) || ( hfinfo -> type == FT_UINT40 ) || ( hfinfo -> type == FT_UINT48 ) || ( hfinfo -> type == FT_UINT56 ) || ( hfinfo -> type == FT_UINT64 ) || ( hfinfo -> type == FT_INT8 ) || ( hfinfo -> type == FT_INT16 ) || ( hfinfo -> type == FT_INT24 ) || ( hfinfo -> type == FT_INT32 ) || ( hfinfo -> type == FT_INT40 ) || ( hfinfo -> type == FT_INT48 ) || ( hfinfo -> type == FT_INT56 ) || ( hfinfo -> type == FT_INT64 ) || ( hfinfo -> type == FT_BOOLEAN ) || ( hfinfo -> type == FT_PROTOCOL ) || ( hfinfo -> type == FT_FRAMENUM ) ) )  g_error ( "Field '%s' (%s) has a 'strings' value but is of type " (which is not allowed to have strings)\n" hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) ) if ( ( hfinfo -> strings != NULL ) && ! ( hfinfo -> display & BASE_RANGE_STRING ) && ! ( ( hfinfo -> display & FIELD_DISPLAY_E_MASK ) == BASE_CUSTOM ) && ( ( hfinfo -> type == FT_UINT8 ) || ( hfinfo -> type == FT_UINT16 ) || ( hfinfo -> type == FT_UINT24 ) || ( hfinfo -> type == FT_UINT32 ) || ( hfinfo -> type == FT_INT8 ) || ( hfinfo -> type == FT_INT16 ) || ( hfinfo -> type == FT_INT24 ) || ( hfinfo -> type == FT_INT32 ) || ( hfinfo -> type == FT_FRAMENUM ) ) )  if ( hfinfo -> display & BASE_EXT_STRING )  start_values = VALUE_STRING_EXT_VS_P ( ( ( const value_string_ext * ) hfinfo -> strings ) ); start_values = ( const value_string * ) hfinfo -> strings; current = start_values; for (n=0; current; n++, current++) if ( ( current -> value == 0 ) && ( current -> strptr == NULL ) )  for (m=0; m < n; m++) if ( ( start_values [ m ] . value == current -> value ) && ( strcmp ( start_values [ m ] . strptr , current -> strptr ) != 0 ) )  g_warning ( "Field '%s' (%s) has a conflicting entry in " value_string: %u is at indices %u (%s) and %u (%s))\n" hfinfo -> name , hfinfo -> abbrev current -> value , m , start_values [ m ] . strptr , n , current -> strptr ) switch ( hfinfo -> type )  switch ( hfinfo -> display & FIELD_DISPLAY_E_MASK )  tmp_str = val_to_str_wmem ( NULL , hfinfo -> display , hf_display , "(Bit count: %d)" ); g_error ( "Field '%s' (%s) is signed (%s) but is being displayed unsigned (%s)\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) , tmp_str ); wmem_free ( NULL , tmp_str ); if ( IS_BASE_PORT ( hfinfo -> display ) )  tmp_str = val_to_str_wmem ( NULL , hfinfo -> display , hf_display , "(Unknown: 0x%x)" ); if ( hfinfo -> type != FT_UINT16 )  g_error ( "Field '%s' (%s) has 'display' value %s but it can only be used with FT_UINT16, not %s\n" , hfinfo -> name , hfinfo -> abbrev , tmp_str , ftype_name ( hfinfo -> type ) ); if ( hfinfo -> strings != NULL )  g_error ( "Field '%s' (%s) is an %s (%s) but has a strings value\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) , tmp_str ); if ( hfinfo -> bitmask != 0 )  g_error ( "Field '%s' (%s) is an %s (%s) but has a bitmask\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) , tmp_str ); wmem_free ( NULL , tmp_str ); switch ( hfinfo -> display & FIELD_DISPLAY_E_MASK )  tmp_str = val_to_str_wmem ( NULL , hfinfo -> display , hf_display , "(Unknown: 0x%x)" ); g_error ( "Field '%s' (%s) is an integral value " but is being displayed as %s\n" hfinfo -> name , hfinfo -> abbrev ftype_name ( hfinfo -> type ) , tmp_str ) wmem_free ( NULL , tmp_str ); switch ( hfinfo -> display & FIELD_DISPLAY_E_MASK )  tmp_str = val_to_str_wmem ( NULL , hfinfo -> display , hf_display , "(Bit count: %d)" ); g_error ( "Field '%s' (%s) is an byte array but is being displayed as %s instead of BASE_NONE, SEP_DOT, SEP_DASH, SEP_COLON, or SEP_SPACE\n" , hfinfo -> name , hfinfo -> abbrev , tmp_str ); wmem_free ( NULL , tmp_str ); if ( hfinfo -> bitmask != 0 )  g_error ( "Field '%s' (%s) is an %s but has a bitmask\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) ); if ( hfinfo -> strings != NULL )  g_error ( "Field '%s' (%s) is an %s but has a strings value\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) ); if ( hfinfo -> display != BASE_NONE )  tmp_str = val_to_str_wmem ( NULL , hfinfo -> display , hf_display , "(Bit count: %d)" ); g_error ( "Field '%s' (%s) is an %s but is being displayed as %s instead of BASE_NONE\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) , tmp_str ); wmem_free ( NULL , tmp_str ); if ( hfinfo -> bitmask != 0 )  g_error ( "Field '%s' (%s) is an %s but has a bitmask\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) ); if ( ! ( hfinfo -> display == ABSOLUTE_TIME_LOCAL || hfinfo -> display == ABSOLUTE_TIME_UTC || hfinfo -> display == ABSOLUTE_TIME_DOY_UTC ) )  tmp_str = val_to_str_wmem ( NULL , hfinfo -> display , hf_display , "(Bit count: %d)" ); g_error ( "Field '%s' (%s) is a %s but is being displayed as %s instead of as a time\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) , tmp_str ); wmem_free ( NULL , tmp_str ); if ( hfinfo -> bitmask != 0 )  g_error ( "Field '%s' (%s) is an %s but has a bitmask\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) ); switch ( hfinfo -> display )  tmp_str = val_to_str_wmem ( NULL , hfinfo -> display , hf_display , "(Unknown: 0x%x)" ); g_error ( "Field '%s' (%s) is an string value " but is being displayed as %s\n" hfinfo -> name , hfinfo -> abbrev ftype_name ( hfinfo -> type ) , tmp_str ) wmem_free ( NULL , tmp_str ); if ( hfinfo -> bitmask != 0 )  g_error ( "Field '%s' (%s) is an %s but has a bitmask\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) ); if ( hfinfo -> strings != NULL )  g_error ( "Field '%s' (%s) is an %s but has a strings value\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) ); switch ( hfinfo -> display )  tmp_str = val_to_str_wmem ( NULL , hfinfo -> display , hf_display , "(Unknown: 0x%x)" ); g_error ( "Field '%s' (%s) is an IPv4 value " but is being displayed as %s\n" hfinfo -> name , hfinfo -> abbrev ftype_name ( hfinfo -> type ) , tmp_str ) wmem_free ( NULL , tmp_str ); if ( hfinfo -> display != BASE_NONE )  tmp_str = val_to_str_wmem ( NULL , hfinfo -> display , hf_display , "(Bit count: %d)" ); g_error ( "Field '%s' (%s) is an %s but is being displayed as %s instead of BASE_NONE\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) , tmp_str ); wmem_free ( NULL , tmp_str ); if ( hfinfo -> bitmask != 0 )  g_error ( "Field '%s' (%s) is an %s but has a bitmask\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) ); if ( hfinfo -> strings != NULL )  g_error ( "Field '%s' (%s) is an %s but has a strings value\n" , hfinfo -> name , hfinfo -> abbrev , ftype_name ( hfinfo -> type ) ); hfinfo -> parent = parent; hfinfo -> same_name_next = NULL; hfinfo -> same_name_prev_id = - 1; gpa_hfinfo . hfi [ gpa_hfinfo . len ] = hfinfo; gpa_hfinfo . len ++; hfinfo -> id = gpa_hfinfo . len - 1; if ( ( hfinfo -> name [ 0 ] != 0 ) && ( hfinfo -> abbrev [ 0 ] != 0 ) )  c = wrs_check_charset ( fld_abbrev_chars , hfinfo -> abbrev ); if ( c )  if ( g_ascii_isprint ( c ) )  fprintf ( stderr , "Invalid character '%c' in filter name '%s'\n" , c , hfinfo -> abbrev ); fprintf ( stderr , "Invalid byte \\%03o in filter name '%s'\n" , c , hfinfo -> abbrev ); g_hash_table_insert ( gpa_name_map , ( gpointer ) ( hfinfo -> abbrev ) , hfinfo ); hfinfo -> same_name_next = same_name_next_hfinfo; same_name_next_hfinfo -> same_name_prev_id = hfinfo -> id; same_name_hfinfo -> same_name_next = hfinfo; hfinfo -> same_name_prev_id = same_name_hfinfo -> id; return hfinfo -> id ; 