static void udp_chr_read(void *opaque) CharDriverState * chr = opaque ; NetCharDriver * s = chr -> opaque ; if ( s -> max_size == 0 )  s -> bufcnt = recv ( s -> fd , ( void * ) s -> buf , sizeof ( s -> buf ) , 0 ); s -> bufptr = s -> bufcnt; if ( s -> bufcnt <= 0 )  s -> bufptr = 0; while ( s -> max_size > 0 && s -> bufptr < s -> bufcnt )  qemu_chr_read ( chr , & s -> buf [ s -> bufptr ] , 1 ); void qemu_chr_read(CharDriverState *s, uint8_t *buf, int len) s -> chr_read ( s -> handler_opaque , buf , len ); s -> bufptr ++; s -> max_size = qemu_chr_can_read ( chr ); int qemu_chr_can_read(CharDriverState *s) if ( ! s -> chr_can_read )  return s -> chr_can_read ( s -> handler_opaque ) ; 