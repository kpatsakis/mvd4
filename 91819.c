static brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device struct cfg80211_ap_settings *settings) s32 ie_offset ; struct brcmf_cfg80211_info * cfg = wiphy_to_cfg ( wiphy ) ; struct brcmf_if * ifp = netdev_priv ( ndev ) ; const struct brcmf_tlv * ssid_ie ; const struct brcmf_tlv * country_ie ; const struct brcmf_tlv * rsn_ie ; const struct brcmf_vs_tlv * wpa_ie ; enum nl80211_iftype dev_role ; u16 chanspec ; bool mbss ; int is_11d ; dev_role = ifp -> vif -> wdev . iftype; mbss = ifp -> vif -> mbss; country_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_COUNTRY ); const struct brcmf_tlv brcmf_parse_tlvs(const void *buf, int buflen, uint key) const struct brcmf_tlv * elt = buf ; int totlen = buflen ; while ( totlen >= TLV_HDR_LEN )  int len = elt -> len ; if ( ( elt -> id == key ) && ( totlen >= ( len + TLV_HDR_LEN ) ) )  return elt ; elt = ( struct brcmf_tlv * ) ( ( u8 * ) elt + ( len + TLV_HDR_LEN ) ); totlen -= ( len + TLV_HDR_LEN ); return NULL ; is_11d = country_ie ? 1 : 0; if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); const struct brcmf_tlv brcmf_parse_tlvs(const void *buf, int buflen, uint key) const struct brcmf_tlv * elt = buf ; int totlen = buflen ; while ( totlen >= TLV_HDR_LEN )  int len = elt -> len ; if ( ( elt -> id == key ) && ( totlen >= ( len + TLV_HDR_LEN ) ) )  return elt ; elt = ( struct brcmf_tlv * ) ( ( u8 * ) elt + ( len + TLV_HDR_LEN ) ); totlen -= ( len + TLV_HDR_LEN ); return NULL ; if ( ! ssid_ie )  rsn_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_RSN ); const struct brcmf_tlv brcmf_parse_tlvs(const void *buf, int buflen, uint key) const struct brcmf_tlv * elt = buf ; int totlen = buflen ; while ( totlen >= TLV_HDR_LEN )  int len = elt -> len ; if ( ( elt -> id == key ) && ( totlen >= ( len + TLV_HDR_LEN ) ) )  return elt ; elt = ( struct brcmf_tlv * ) ( ( u8 * ) elt + ( len + TLV_HDR_LEN ) ); totlen -= ( len + TLV_HDR_LEN ); return NULL ; wpa_ie = brcmf_find_wpaie ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len ); static struct brcmf_vs_tlv brcmf_find_wpaie(const u8 *parse, u32 len) const struct brcmf_tlv * ie ; while ( ie = brcmf_parse_tlvs ( parse , len , WLAN_EID_VENDOR_SPECIFIC ) )  const struct brcmf_tlv brcmf_parse_tlvs(const void *buf, int buflen, uint key) const struct brcmf_tlv * elt = buf ; int totlen = buflen ; while ( totlen >= TLV_HDR_LEN )  int len = elt -> len ; if ( ( elt -> id == key ) && ( totlen >= ( len + TLV_HDR_LEN ) ) )  return elt ; elt = ( struct brcmf_tlv * ) ( ( u8 * ) elt + ( len + TLV_HDR_LEN ) ); totlen -= ( len + TLV_HDR_LEN ); return NULL ; if ( brcmf_tlv_has_ie ( ( const u8 * ) ie , & parse , & len , WPA_OUI , TLV_OUI_LEN , WPA_OUI_TYPE ) )  static brcmf_tlv_has_ie(const u8 *ie, const u8 **tlvs, u32 const u8 *oui, u32 oui_len, u8 type) if ( ie [ TLV_LEN_OFF ] >= oui_len + 1 && ! memcmp ( & ie [ TLV_BODY_OFF ] , oui , oui_len ) && type == ie [ TLV_BODY_OFF + oui_len ] )  return true ; if ( tlvs == NULL )  return false ; return false ; return ( struct brcmf_vs_tlv * ) ie ; return NULL ; if ( wpa_ie != NULL || rsn_ie != NULL )  if ( wpa_ie != NULL )  err = brcmf_configure_wpaie ( ifp , wpa_ie , false ); static brcmf_configure_wpaie(struct brcmf_if const struct brcmf_vs_tlv bool is_rsn_ie) u32 auth = 0 ; u16 count ; s32 err = 0 ; s32 len ; u32 i ; u32 wsec ; u32 pval = 0 ; u32 wpa_auth = 0 ; u32 offset ; u8 * data ; u16 rsn_cap ; u32 wme_bss_disable ; u32 mfp ; if ( wpa_ie == NULL )  len = wpa_ie -> len + TLV_HDR_LEN; data = ( u8 * ) wpa_ie; offset = TLV_HDR_LEN; if ( ! is_rsn_ie )  offset += VS_IE_FIXED_HDR_LEN; offset += WPA_IE_VERSION_LEN; if ( offset + WPA_IE_MIN_OUI_LEN > len )  err = - EINVAL; if ( ! brcmf_valid_wpa_oui ( & data [ offset ] , is_rsn_ie ) )  static bool brcmf_valid_wpa_oui(u8 *oui, bool is_rsn_ie) if ( is_rsn_ie )  return ( memcmp ( oui , RSN_OUI , TLV_OUI_LEN ) == 0 ) ; return ( memcmp ( oui , WPA_OUI , TLV_OUI_LEN ) == 0 ) ; err = - EINVAL; offset += TLV_OUI_LEN; switch ( data [ offset ] )  gval = 0; gval = WEP_ENABLED; gval = TKIP_ENABLED; gval = AES_ENABLED; err = - EINVAL; offset ++; count = data [ offset ] + ( data [ offset + 1 ] << 8 ); offset += WPA_IE_SUITE_COUNT_LEN; if ( offset + ( WPA_IE_MIN_OUI_LEN * count ) > len )  err = - EINVAL; for (i = 0; i < count; i++) if ( ! brcmf_valid_wpa_oui ( & data [ offset ] , is_rsn_ie ) )  static bool brcmf_valid_wpa_oui(u8 *oui, bool is_rsn_ie) if ( is_rsn_ie )  return ( memcmp ( oui , RSN_OUI , TLV_OUI_LEN ) == 0 ) ; return ( memcmp ( oui , WPA_OUI , TLV_OUI_LEN ) == 0 ) ; err = - EINVAL; offset += TLV_OUI_LEN; switch ( data [ offset ] )  pval |= WEP_ENABLED; pval |= TKIP_ENABLED; pval |= AES_ENABLED; offset ++; count = data [ offset ] + ( data [ offset + 1 ] << 8 ); offset += WPA_IE_SUITE_COUNT_LEN; if ( offset + ( WPA_IE_MIN_OUI_LEN * count ) > len )  err = - EINVAL; for (i = 0; i < count; i++) if ( ! brcmf_valid_wpa_oui ( & data [ offset ] , is_rsn_ie ) )  static bool brcmf_valid_wpa_oui(u8 *oui, bool is_rsn_ie) if ( is_rsn_ie )  return ( memcmp ( oui , RSN_OUI , TLV_OUI_LEN ) == 0 ) ; return ( memcmp ( oui , WPA_OUI , TLV_OUI_LEN ) == 0 ) ; err = - EINVAL; offset += TLV_OUI_LEN; switch ( data [ offset ] )  wpa_auth |= WPA_AUTH_NONE; is_rsn_ie ? ( wpa_auth |= WPA2_AUTH_UNSPECIFIED ) : ( wpa_auth |= WPA_AUTH_UNSPECIFIED ); is_rsn_ie ? ( wpa_auth |= WPA2_AUTH_PSK ) : ( wpa_auth |= WPA_AUTH_PSK ); wpa_auth |= WPA2_AUTH_PSK_SHA256; wpa_auth |= WPA2_AUTH_1X_SHA256; offset ++; mfp = BRCMF_MFP_NONE; if ( is_rsn_ie )  wme_bss_disable = 1; if ( ( offset + RSN_CAP_LEN ) <= len )  rsn_cap = data [ offset ] + ( data [ offset + 1 ] << 8 ); if ( rsn_cap & RSN_CAP_PTK_REPLAY_CNTR_MASK )  wme_bss_disable = 0; if ( rsn_cap & RSN_CAP_MFPR_MASK )  mfp = BRCMF_MFP_REQUIRED; if ( ! ( wpa_auth & ( WPA2_AUTH_PSK_SHA256 | WPA2_AUTH_1X_SHA256 ) ) )  err = - EINVAL; if ( wpa_auth & WPA2_AUTH_PSK_SHA256 )  wpa_auth |= WPA2_AUTH_PSK; if ( wpa_auth & WPA2_AUTH_1X_SHA256 )  wpa_auth |= WPA2_AUTH_UNSPECIFIED; if ( rsn_cap & RSN_CAP_MFPC_MASK )  mfp = BRCMF_MFP_CAPABLE; offset += RSN_CAP_LEN; err = brcmf_fil_bsscfg_int_set ( ifp , "wme_bss_disable" , wme_bss_disable ); if ( err < 0 )  offset += RSN_PMKID_COUNT_LEN; if ( brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_MFP ) && ( ( offset + WPA_IE_MIN_OUI_LEN ) <= len ) )  err = brcmf_fil_bsscfg_data_set ( ifp , "bip" , & data [ offset ] , WPA_IE_MIN_OUI_LEN ); if ( err < 0 )  wsec = ( pval | gval | SES_OW_ENABLED ); err = brcmf_fil_bsscfg_int_set ( ifp , "auth" , auth ); if ( err < 0 )  err = brcmf_fil_bsscfg_int_set ( ifp , "wsec" , wsec ); if ( err < 0 )  if ( brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_MFP ) )  err = brcmf_fil_bsscfg_int_set ( ifp , "mfp" , mfp ); if ( err < 0 )  err = brcmf_fil_bsscfg_int_set ( ifp , "wpa_auth" , wpa_auth ); return err ; if ( err < 0 )  struct brcmf_vs_tlv * tmp_ie ; tmp_ie = ( struct brcmf_vs_tlv * ) rsn_ie; err = brcmf_configure_wpaie ( ifp , tmp_ie , true ); static brcmf_configure_wpaie(struct brcmf_if const struct brcmf_vs_tlv bool is_rsn_ie) u32 auth = 0 ; u16 count ; s32 err = 0 ; s32 len ; u32 i ; u32 wsec ; u32 pval = 0 ; u32 wpa_auth = 0 ; u32 offset ; u8 * data ; u16 rsn_cap ; u32 wme_bss_disable ; u32 mfp ; if ( wpa_ie == NULL )  len = wpa_ie -> len + TLV_HDR_LEN; data = ( u8 * ) wpa_ie; offset = TLV_HDR_LEN; if ( ! is_rsn_ie )  offset += VS_IE_FIXED_HDR_LEN; offset += WPA_IE_VERSION_LEN; if ( offset + WPA_IE_MIN_OUI_LEN > len )  err = - EINVAL; if ( ! brcmf_valid_wpa_oui ( & data [ offset ] , is_rsn_ie ) )  err = - EINVAL; offset += TLV_OUI_LEN; switch ( data [ offset ] )  gval = 0; gval = WEP_ENABLED; gval = TKIP_ENABLED; gval = AES_ENABLED; err = - EINVAL; offset ++; count = data [ offset ] + ( data [ offset + 1 ] << 8 ); offset += WPA_IE_SUITE_COUNT_LEN; if ( offset + ( WPA_IE_MIN_OUI_LEN * count ) > len )  err = - EINVAL; if ( ! brcmf_valid_wpa_oui ( & data [ offset ] , is_rsn_ie ) )  err = - EINVAL; offset += TLV_OUI_LEN; switch ( data [ offset ] )  pval |= WEP_ENABLED; pval |= TKIP_ENABLED; pval |= AES_ENABLED; offset ++; count = data [ offset ] + ( data [ offset + 1 ] << 8 ); offset += WPA_IE_SUITE_COUNT_LEN; if ( offset + ( WPA_IE_MIN_OUI_LEN * count ) > len )  err = - EINVAL; if ( ! brcmf_valid_wpa_oui ( & data [ offset ] , is_rsn_ie ) )  err = - EINVAL; offset += TLV_OUI_LEN; switch ( data [ offset ] )  wpa_auth |= WPA_AUTH_NONE; is_rsn_ie ? ( wpa_auth |= WPA2_AUTH_UNSPECIFIED ) : ( wpa_auth |= WPA_AUTH_UNSPECIFIED ); is_rsn_ie ? ( wpa_auth |= WPA2_AUTH_PSK ) : ( wpa_auth |= WPA_AUTH_PSK ); wpa_auth |= WPA2_AUTH_PSK_SHA256; wpa_auth |= WPA2_AUTH_1X_SHA256; offset ++; mfp = BRCMF_MFP_NONE; if ( is_rsn_ie )  wme_bss_disable = 1; if ( ( offset + RSN_CAP_LEN ) <= len )  rsn_cap = data [ offset ] + ( data [ offset + 1 ] << 8 ); if ( rsn_cap & RSN_CAP_PTK_REPLAY_CNTR_MASK )  wme_bss_disable = 0; if ( rsn_cap & RSN_CAP_MFPR_MASK )  mfp = BRCMF_MFP_REQUIRED; if ( ! ( wpa_auth & ( WPA2_AUTH_PSK_SHA256 | WPA2_AUTH_1X_SHA256 ) ) )  err = - EINVAL; if ( wpa_auth & WPA2_AUTH_PSK_SHA256 )  wpa_auth |= WPA2_AUTH_PSK; if ( wpa_auth & WPA2_AUTH_1X_SHA256 )  wpa_auth |= WPA2_AUTH_UNSPECIFIED; if ( rsn_cap & RSN_CAP_MFPC_MASK )  mfp = BRCMF_MFP_CAPABLE; offset += RSN_CAP_LEN; err = brcmf_fil_bsscfg_int_set ( ifp , "wme_bss_disable" , wme_bss_disable ); if ( err < 0 )  offset += RSN_PMKID_COUNT_LEN; if ( brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_MFP ) && ( ( offset + WPA_IE_MIN_OUI_LEN ) <= len ) )  err = brcmf_fil_bsscfg_data_set ( ifp , "bip" , & data [ offset ] , WPA_IE_MIN_OUI_LEN ); if ( err < 0 )  wsec = ( pval | gval | SES_OW_ENABLED ); err = brcmf_fil_bsscfg_int_set ( ifp , "auth" , auth ); if ( err < 0 )  err = brcmf_fil_bsscfg_int_set ( ifp , "wsec" , wsec ); if ( err < 0 )  if ( brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_MFP ) )  err = brcmf_fil_bsscfg_int_set ( ifp , "mfp" , mfp ); if ( err < 0 )  err = brcmf_fil_bsscfg_int_set ( ifp , "wpa_auth" , wpa_auth ); return err ; if ( err < 0 )  if ( ! mbss )  chanspec = chandef_to_chanspec ( & cfg -> d11inf , & settings -> chandef ); static u16 chandef_to_chanspec(struct brcmu_d11inf struct cfg80211_chan_def *ch) struct brcmu_chan ch_inf ; s32 primary_offset ; ch_inf . chnum = ieee80211_frequency_to_channel ( ch -> center_freq1 ); primary_offset = ch -> chan -> center_freq - ch -> center_freq1; switch ( ch -> width )  ch_inf . bw = BRCMU_CHAN_BW_20; ch_inf . bw = BRCMU_CHAN_BW_40; if ( primary_offset > 0 )  ch_inf . sb = BRCMU_CHAN_SB_U; ch_inf . sb = BRCMU_CHAN_SB_L; ch_inf . bw = BRCMU_CHAN_BW_80; if ( primary_offset == - 30 )  ch_inf . sb = BRCMU_CHAN_SB_LL; if ( primary_offset == - 10 )  ch_inf . sb = BRCMU_CHAN_SB_LU; if ( primary_offset == 10 )  ch_inf . sb = BRCMU_CHAN_SB_UL; ch_inf . sb = BRCMU_CHAN_SB_UU; switch ( ch -> chan -> band )  ch_inf . band = BRCMU_CHAN_BAND_2G; ch_inf . band = BRCMU_CHAN_BAND_5G; return ch_inf . chspec ; err = brcmf_fil_iovar_int_set ( ifp , "chanspec" , chanspec ); if ( err < 0 )  if ( is_11d != ifp -> vif -> is_11d )  err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_REGULATORY , is_11d ); if ( err < 0 )  if ( settings -> beacon_interval )  err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_BCNPRD , settings -> beacon_interval ); if ( err < 0 )  if ( settings -> dtim_period )  err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_DTIMPRD , settings -> dtim_period ); if ( err < 0 )  if ( ( dev_role == NL80211_IFTYPE_AP ) && ( ( ifp -> ifidx == 0 ) || ! brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_RSDB ) ) )  err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_DOWN , 1 ); if ( err < 0 )  err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_INFRA , 1 ); if ( err < 0 )  if ( WARN_ON ( is_11d != ifp -> vif -> is_11d ) )  if ( dev_role == NL80211_IFTYPE_AP )  err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_AP , 1 ); if ( err < 0 )  err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_UP , 1 ); if ( err < 0 )  brcmf_cfg80211_reconfigure_wep ( ifp ); static brcmf_cfg80211_reconfigure_wep(struct brcmf_if *ifp) s32 err ; u8 key_idx ; struct brcmf_wsec_key * key ; for (key_idx = 0; key_idx < BRCMF_MAX_DEFAULT_KEYS; key_idx++) key = & ifp -> vif -> profile . key [ key_idx ]; if ( ( key -> algo == CRYPTO_ALGO_WEP1 ) || ( key -> algo == CRYPTO_ALGO_WEP128 ) )  if ( key_idx == BRCMF_MAX_DEFAULT_KEYS )  err = send_key_to_dongle ( ifp , key ); static send_key_to_dongle(struct brcmf_if *ifp, struct brcmf_wsec_key *key) struct brcmf_wsec_key_le key_le ; convert_key_from_CPU ( key , & key_le ); static void convert_key_from_CPU(struct brcmf_wsec_key struct brcmf_wsec_key_le *key_le) key_le -> index = cpu_to_le32 ( key -> index ); key_le -> len = cpu_to_le32 ( key -> len ); key_le -> algo = cpu_to_le32 ( key -> algo ); key_le -> flags = cpu_to_le32 ( key -> flags ); key_le -> rxiv . hi = cpu_to_le32 ( key -> rxiv . hi ); key_le -> rxiv . lo = cpu_to_le16 ( key -> rxiv . lo ); key_le -> iv_initialized = cpu_to_le32 ( key -> iv_initialized ); memcpy ( key_le -> data , key -> data , sizeof ( key -> data ) ); memcpy ( key_le -> ea , key -> ea , sizeof ( key -> ea ) ); 