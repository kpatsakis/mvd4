 nestegg_read_packet(nestegg * ctx, nestegg_packet ** pkt) uint64_t id , size ; * pkt = NULL; r = ne_peek_element ( ctx , & id , & size ); if ( r != 1 )  if ( ne_is_suspend_element ( id ) )  r = ne_read_element ( ctx , & id , & size ); if ( r != 1 )  r = ne_read_block ( ctx , id , size , pkt ); if ( r != 1 )  if ( id != ID_SIMPLE_BLOCK )  r = ne_read_block_duration ( ctx , * pkt ); static ne_read_block_duration(nestegg * ctx, nestegg_packet * pkt) int r ; uint64_t id , size ; struct ebml_element_desc * element ; r = ne_peek_element ( ctx , & id , & size ); static ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; if ( ctx -> last_valid )  return 1 ; r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL ); if ( r != 1 )  return r ; r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  return r ; if ( id != ID_BLOCK_DURATION )  return 1 ; element = ne_find_element ( id , ctx -> ancestor -> node ); static struct ebml_element_desc ne_find_element(uint64_t id, struct ebml_element_desc * elements) struct ebml_element_desc * element ; for (element = elements; element->id; ++element) if ( element -> id == id )  return element ; return NULL ; if ( ! element )  return 1 ; r = ne_read_simple ( ctx , element , size ); static ne_read_simple(nestegg * ctx, struct ebml_element_desc * desc, size_t length) struct ebml_type * storage ; int r ; storage = ( struct ebml_type * ) ( ctx -> ancestor -> data + desc -> offset ); if ( storage -> read )  return 0 ; storage -> type = desc -> type; switch ( desc -> type )  r = ne_read_uint ( ctx -> io , & storage -> v . u , length ); r = ne_read_float ( ctx -> io , & storage -> v . f , length ); r = ne_read_int ( ctx -> io , & storage -> v . i , length ); r = ne_read_string ( ctx , & storage -> v . s , length ); r = ne_read_binary ( ctx , & storage -> v . b , length ); r = 0; return r ; if ( r != 1 )  return r ; return 1 ; if ( r < 0 )  r = ne_read_discard_padding ( ctx , * pkt ); static ne_read_discard_padding(nestegg * ctx, nestegg_packet * pkt) int r ; uint64_t id , size ; struct ebml_element_desc * element ; r = ne_peek_element ( ctx , & id , & size ); static ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; if ( ctx -> last_valid )  return 1 ; r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL ); if ( r != 1 )  return r ; r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  return r ; if ( id != ID_DISCARD_PADDING )  return 1 ; element = ne_find_element ( id , ctx -> ancestor -> node ); static struct ebml_element_desc ne_find_element(uint64_t id, struct ebml_element_desc * elements) struct ebml_element_desc * element ; if ( element -> id == id )  return element ; return NULL ; if ( ! element )  return 1 ; r = ne_read_simple ( ctx , element , size ); static ne_read_simple(nestegg * ctx, struct ebml_element_desc * desc, size_t length) struct ebml_type * storage ; int r ; storage = ( struct ebml_type * ) ( ctx -> ancestor -> data + desc -> offset ); if ( storage -> read )  return 0 ; storage -> type = desc -> type; switch ( desc -> type )  r = ne_read_uint ( ctx -> io , & storage -> v . u , length ); r = ne_read_float ( ctx -> io , & storage -> v . f , length ); r = ne_read_int ( ctx -> io , & storage -> v . i , length ); r = ne_read_string ( ctx , & storage -> v . s , length ); r = ne_read_binary ( ctx , & storage -> v . b , length ); r = 0; return r ; if ( r != 1 )  return r ; return 1 ; if ( r < 0 )  r = ne_read_block_additions ( ctx , * pkt ); r = ne_parse ( ctx , NULL , - 1 ); if ( r != 1 )  static ne_read_block_additions(nestegg * ctx, nestegg_packet * pkt) int r ; uint64_t id , size , data_size ; int64_t block_additions_end , block_more_end ; void * data ; int has_data ; struct block_additional * block_additional ; uint64_t add_id ; r = ne_peek_element ( ctx , & id , & size ); static ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; if ( ctx -> last_valid )  return 1 ; r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL ); if ( r != 1 )  return r ; r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  if ( id != ID_BLOCK_ADDITIONS )  ctx -> last_valid = 0; block_additions_end = ne_io_tell ( ctx -> io ) + size; static ne_io_tell(nestegg_io * io) return io -> tell ( io -> userdata ) ; while ( ne_io_tell ( ctx -> io ) < block_additions_end )  static ne_io_tell(nestegg_io * io) return io -> tell ( io -> userdata ) ; add_id = 1; data = NULL; has_data = 0; r = ne_read_element ( ctx , & id , & size ); static ne_read_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; r = ne_peek_element ( ctx , id , size ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  if ( id != ID_BLOCK_MORE )  block_more_end = ne_io_tell ( ctx -> io ) + size; static ne_io_tell(nestegg_io * io) return io -> tell ( io -> userdata ) ; while ( ne_io_tell ( ctx -> io ) < block_more_end )  static ne_io_tell(nestegg_io * io) return io -> tell ( io -> userdata ) ; r = ne_read_element ( ctx , & id , & size ); static ne_read_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; r = ne_peek_element ( ctx , id , size ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  if ( id == ID_BLOCK_ADD_ID )  r = ne_read_uint ( ctx -> io , & add_id , size ); static ne_read_uint(nestegg_io * io, uint64_t * val, uint64_t length) int r ; if ( length == 0 || length > 8 )  return - 1 ; r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; while ( -- length )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  if ( add_id == 0 )  if ( id == ID_BLOCK_ADDITIONAL )  if ( has_data )  has_data = 1; data_size = size; if ( size != 0 )  data = ne_alloc ( size ); r = ne_io_read ( ctx -> io , data , size ); static ne_io_read(nestegg_io * io, void * buffer, size_t length) return io -> read ( buffer , length , io -> userdata ) ; if ( r != 1 )  if ( has_data == 0 )  block_additional = ne_alloc ( sizeof ( * block_additional ) ); block_additional -> next = pkt -> block_additional; block_additional -> id = add_id; block_additional -> data = data; block_additional -> length = data_size; pkt -> block_additional = block_additional; static void ne_alloc(size_t size) return calloc ( 1 , size ) ; 