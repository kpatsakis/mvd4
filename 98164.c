int attribute_align_arg avcodec_encode_audio(AVCodecContext uint8_t *buf, int const short *samples) AVPacket pkt ; AVFrame * frame ; int ret , samples_size , got_packet ; pkt . data = buf; pkt . size = buf_size; if ( samples )  frame = av_frame_alloc ( ); if ( ! frame )  if ( avctx -> frame_size )  frame -> nb_samples = avctx -> frame_size; int64_t nb_samples ; if ( ! av_get_bits_per_sample ( avctx -> codec_id ) )  int av_get_bits_per_sample(enum AVCodecID codec_id) switch ( codec_id )  return 2 ; return 3 ; return 4 ; return av_get_exact_bits_per_sample ( codec_id ) ; int av_get_exact_bits_per_sample(enum AVCodecID codec_id) switch ( codec_id )  return 4 ; return 8 ; return 16 ; return 24 ; return 32 ; return 64 ; return 0 ; nb_samples = ( int64_t ) buf_size * 8 / ( av_get_bits_per_sample ( avctx -> codec_id ) * avctx -> channels ); int av_get_bits_per_sample(enum AVCodecID codec_id) switch ( codec_id )  return 2 ; return 3 ; return 4 ; return av_get_exact_bits_per_sample ( codec_id ) ; if ( nb_samples >= INT_MAX )  frame -> nb_samples = nb_samples; samples_size = av_samples_get_buffer_size ( NULL , avctx -> channels , frame -> nb_samples , avctx -> sample_fmt , 1 ); if ( ( ret = avcodec_fill_audio_frame ( frame , avctx -> channels , avctx -> sample_fmt , ( const uint8_t * ) samples , samples_size , 1 ) ) < 0 )  int avcodec_fill_audio_frame(AVFrame *frame, int enum AVSampleFormat sample_fmt, const uint8_t int buf_size, int align) needed_size = av_samples_get_buffer_size ( NULL , nb_channels , frame -> nb_samples , sample_fmt , align ); if ( buf_size < needed_size )  return AVERROR ( EINVAL ) ; planar = av_sample_fmt_is_planar ( sample_fmt ); if ( planar && nb_channels > AV_NUM_DATA_POINTERS )  if ( ! ( frame -> extended_data = av_mallocz_array ( nb_channels , sizeof ( * frame -> extended_data ) ) ) )  return AVERROR ( ENOMEM ) ; frame -> extended_data = frame -> data; if ( ( ret = av_samples_fill_arrays ( frame -> extended_data , & frame -> linesize [ 0 ] , ( uint8_t * ) ( intptr_t ) buf , nb_channels , frame -> nb_samples , sample_fmt , align ) ) < 0 )  return ret ; return ret ; if ( avctx -> sample_rate && avctx -> time_base . num )  frame -> pts = ff_samples_to_time_base ( avctx , avctx -> internal -> sample_count ); frame -> pts = AV_NOPTS_VALUE; avctx -> internal -> sample_count += frame -> nb_samples; frame = NULL; got_packet = 0; ret = avcodec_encode_audio2 ( avctx , & pkt , frame , & got_packet ); int attribute_align_arg avcodec_encode_audio2(AVCodecContext AVPacket const AVFrame int *got_packet_ptr) if ( ! ( avctx -> codec -> capabilities & AV_CODEC_CAP_DELAY ) && ! frame )  if ( frame && ! frame -> extended_data )  if ( av_sample_fmt_is_planar ( avctx -> sample_fmt ) && avctx -> channels > AV_NUM_DATA_POINTERS )  extended_frame = av_frame_alloc ( ); if ( ! extended_frame )  memcpy ( extended_frame , frame , sizeof ( AVFrame ) ); extended_frame -> extended_data = extended_frame -> data; frame = extended_frame; if ( frame )  AVFrameSideData * sd = av_frame_get_side_data ( frame , AV_FRAME_DATA_AUDIO_SERVICE_TYPE ) ; if ( sd && sd -> size >= sizeof ( enum AVAudioServiceType ) )  avctx -> audio_service_type = * ( enum AVAudioServiceType * ) sd -> data; if ( frame )  if ( avctx -> codec -> capabilities & AV_CODEC_CAP_SMALL_LAST_FRAME )  if ( frame -> nb_samples > avctx -> frame_size )  av_log ( avctx , AV_LOG_ERROR , "more samples than frame size (avcodec_encode_audio2)\n" ); if ( ! ( avctx -> codec -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) )  if ( frame -> nb_samples < avctx -> frame_size && ! avctx -> internal -> last_audio_frame )  ret = pad_last_frame ( avctx , & padded_frame , frame ); static int pad_last_frame(AVCodecContext *s, AVFrame **dst, const AVFrame *src) frame -> format = src -> format; frame -> channel_layout = src -> channel_layout; av_frame_set_channels ( frame , av_frame_get_channels ( src ) ); frame -> nb_samples = s -> frame_size; ret = av_frame_get_buffer ( frame , 32 ); if ( ret < 0 )  ret = av_frame_copy_props ( frame , src ); if ( ret < 0 )  if ( ( ret = av_samples_copy ( frame -> extended_data , src -> extended_data , 0 , 0 , src -> nb_samples , s -> channels , s -> sample_fmt ) ) < 0 )  if ( ( ret = av_samples_set_silence ( frame -> extended_data , src -> nb_samples , frame -> nb_samples - src -> nb_samples , s -> channels , s -> sample_fmt ) ) < 0 )  * dst = frame; av_frame_free ( & frame ); return ret ; if ( ret < 0 )  avctx -> internal -> last_audio_frame = 1; if ( frame -> nb_samples != avctx -> frame_size )  av_log ( avctx , AV_LOG_ERROR , "nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\n" , frame -> nb_samples , avctx -> frame_size ); av_assert0 ( avctx -> codec -> encode2 ); ret = avctx -> codec -> encode2 ( avctx , avpkt , frame , got_packet_ptr ); if ( ! ret )  if ( ! ( avctx -> codec -> capabilities & AV_CODEC_CAP_DELAY ) )  avpkt -> pts = frame -> pts; if ( ! avpkt -> duration )  avpkt -> duration = ff_samples_to_time_base ( avctx , frame -> nb_samples ); avpkt -> dts = avpkt -> pts; if ( avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer )  if ( user_pkt . size >= avpkt -> size )  memcpy ( user_pkt . data , avpkt -> data , avpkt -> size ); av_log ( avctx , AV_LOG_ERROR , "Provided packet is too small, needs to be %d\n" , avpkt -> size ); avpkt -> buf = user_pkt . buf; avpkt -> data = user_pkt . data; avpkt -> destruct = user_pkt . destruct; if ( ! ret )  if ( needs_realloc && avpkt -> data )  ret = av_buffer_realloc ( & avpkt -> buf , avpkt -> size + AV_INPUT_BUFFER_PADDING_SIZE ); if ( ret >= 0 )  avpkt -> data = avpkt -> buf -> data; avctx -> frame_number ++; if ( ret < 0 || ! * got_packet_ptr )  av_free_packet ( avpkt ); av_init_packet ( avpkt ); avpkt -> flags |= AV_PKT_FLAG_KEY; av_free ( extended_frame ); avctx -> delay = avctx -> initial_padding; return ret ; 