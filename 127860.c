static int CVE_2013_7011_PATCHED_read_header(FFV1Context *f) uint8_t state [ CONTEXT_SIZE ] ; memset ( state , 128 , sizeof ( state ) ); unsigned v = get_symbol ( c , state , 0 ) ; if ( v >= 2 )  av_log ( f -> avctx , AV_LOG_ERROR , "invalid version %d in ver01 header\n" , v ); f -> version = v; f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); if ( f -> ac > 1 )  f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; f -> colorspace = get_symbol ( c , state , 0 ); if ( f -> version > 0 )  f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); chroma_planes = get_rac ( c , state ); chroma_h_shift = get_symbol ( c , state , 0 ); chroma_v_shift = get_symbol ( c , state , 0 ); transparency = get_rac ( c , state ); if ( f -> plane_count )  if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency )  av_log ( f -> avctx , AV_LOG_ERROR , "Invalid change of global parameters\n" ); f -> chroma_planes = chroma_planes; f -> chroma_h_shift = chroma_h_shift; f -> chroma_v_shift = chroma_v_shift; f -> transparency = transparency; f -> plane_count = 2 + f -> transparency; if ( f -> colorspace == 0 )  if ( ! f -> transparency && ! f -> chroma_planes )  if ( f -> avctx -> bits_per_raw_sample <= 8 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); if ( f -> avctx -> bits_per_raw_sample == 9 )  switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  if ( f -> avctx -> bits_per_raw_sample == 10 )  switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); if ( f -> colorspace == 1 )  if ( f -> chroma_h_shift || f -> chroma_v_shift )  av_log ( f -> avctx , AV_LOG_ERROR , "chroma subsampling not supported in this colorspace\n" ); if ( f -> avctx -> bits_per_raw_sample == 9 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; if ( f -> avctx -> bits_per_raw_sample == 10 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; if ( f -> avctx -> bits_per_raw_sample == 12 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; if ( f -> avctx -> bits_per_raw_sample == 14 )  f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; if ( f -> transparency )  f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; av_log ( f -> avctx , AV_LOG_ERROR , "colorspace not supported\n" ); av_dlog ( f -> avctx , "%d %d %d\n" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ); if ( f -> version < 2 )  context_count = read_quant_tables ( c , f -> quant_table ); if ( context_count < 0 )  av_log ( f -> avctx , AV_LOG_ERROR , "read_quant_table error\n" ); if ( f -> version < 3 )  f -> slice_count = get_symbol ( c , state , 0 ); if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  av_log ( f -> avctx , AV_LOG_ERROR , "slice count %d is invalid\n" , f -> slice_count ); for (j = 0; j < f->slice_count; j++) FFV1Context * fs = f -> slice_context [ j ] ; fs -> ac = f -> ac; fs -> packed_at_lsb = f -> packed_at_lsb; fs -> slice_damaged = 0; if ( f -> version == 2 )  fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; fs -> slice_x /= f -> num_h_slices; fs -> slice_y /= f -> num_v_slices; fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  for (i = 0; i < f->plane_count; i++) PlaneContext * const p = & fs -> plane [ i ] if ( f -> version == 2 )  int idx = get_symbol ( c , state , 0 ) ; if ( idx > ( unsigned ) f -> quant_table_count )  av_log ( f -> avctx , AV_LOG_ERROR , "quant_table_index out of range\n" ); p -> quant_table_index = idx; memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); context_count = f -> context_count [ idx ]; memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); if ( f -> version <= 2 )  av_assert0 ( context_count >= 0 ); if ( p -> context_count < context_count )  av_freep ( & p -> state ); av_freep ( & p -> vlc_state ); p -> context_count = context_count; 