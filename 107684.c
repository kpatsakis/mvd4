static void vmsvga_update_display(void *opaque) struct vmsvga_state_s * s = opaque ; if ( ! s -> enable )  vmsvga_update_rect_flush ( s ); static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s) struct vmsvga_rect_s * rect ; if ( s -> invalidated )  while ( s -> redraw_fifo_first != s -> redraw_fifo_last )  rect = & s -> redraw_fifo [ s -> redraw_fifo_first ++ ]; s -> redraw_fifo_first &= REDRAW_FIFO_LEN - 1; vmsvga_update_rect ( s , rect -> x , rect -> y , rect -> w , rect -> h ); static inline void vmsvga_update_rect(struct vmsvga_state_s int x, int y, int w, int h) DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ; int line ; int bypl ; int width ; int start ; uint8_t * src ; uint8_t * dst ; if ( ! vmsvga_verify_rect ( surface , __func__ , x , y , w , h ) )  static inline bool vmsvga_verify_rect(DisplaySurface const char int x, int y, int w, int h) if ( x < 0 )  return false ; if ( x > SVGA_MAX_WIDTH )  return false ; if ( w < 0 )  return false ; if ( w > SVGA_MAX_WIDTH )  return false ; if ( x + w > surface_width ( surface ) )  return false ; if ( y < 0 )  return false ; if ( y > SVGA_MAX_HEIGHT )  return false ; if ( h < 0 )  return false ; if ( h > SVGA_MAX_HEIGHT )  return false ; if ( y + h > surface_height ( surface ) )  return false ; return true ; x = 0; y = 0; w = surface_width ( surface ); h = surface_height ( surface ); bypl = surface_stride ( surface ); width = surface_bytes_per_pixel ( surface ) * w; start = surface_bytes_per_pixel ( surface ) * x + bypl * y; src = s -> vga . vram_ptr + start; dst = surface_data ( surface ) + start; for (line = h; line > 0; line--, src += bypl, dst += bypl) memcpy ( dst , src , width ); 