static void fw_cfg_bootsplash(FWCfgState *s) int boot_splash_time = - 1 ; char * p ; const char * temp ; QemuOptsList * plist = qemu_find_opts ( "boot-opts" ) ; QemuOpts * opts = QTAILQ_FIRST ( & plist -> head ) ; if ( opts != NULL )  temp = qemu_opt_get ( opts , "splash" ); temp = qemu_opt_get ( opts , "splash-time" ); if ( temp != NULL )  p = ( char * ) temp; boot_splash_time = strtol ( p , ( char * * ) & p , 10 ); if ( boot_splash_time >= 0 )  if ( boot_splash_time > 0xffff )  boot_splash_time = 0xffff; qemu_extra_params_fw [ 0 ] = ( uint8_t ) ( boot_splash_time & 0xff ); qemu_extra_params_fw [ 1 ] = ( uint8_t ) ( ( boot_splash_time >> 8 ) & 0xff ); fw_cfg_add_file ( s , "etc/boot-menu-wait" , qemu_extra_params_fw , 2 ); void fw_cfg_add_file(FWCfgState *s,  const char void *data, size_t len) fw_cfg_add_file_callback ( s , filename , NULL , NULL , data , len ); void fw_cfg_add_file_callback(FWCfgState *s,  const char FWCfgReadCallback callback, void void *data, size_t len) int i , index ; size_t dsize ; if ( ! s -> files )  dsize = sizeof ( uint32_t ) + sizeof ( FWCfgFile ) * FW_CFG_FILE_SLOTS; s -> files = g_malloc0 ( dsize ); index = be32_to_cpu ( s -> files -> count ); fw_cfg_add_bytes_read_callback ( s , FW_CFG_FILE_FIRST + index , callback , callback_opaque , data , len ); static void fw_cfg_add_bytes_read_callback(FWCfgState *s, uint16_t FWCfgReadCallback void void *data, size_t len) key &= FW_CFG_ENTRY_MASK; assert ( key < FW_CFG_MAX_ENTRY && len < UINT32_MAX ); 