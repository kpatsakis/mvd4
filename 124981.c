      attrlist_cursor_kern_t *cursor) xfs_attr_list_context_t context ; int error ; if ( cursor -> pad1 || cursor -> pad2 )  if ( ( cursor -> initted == 0 ) && ( cursor -> hashval || cursor -> blkno || cursor -> offset ) )  if ( ( ( long ) buffer ) & ( sizeof ( int ) - 1 ) )  if ( flags & ATTR_KERNOVAL )  bufsize = 0; memset ( & context , 0 , sizeof ( context ) ); context . dp = dp; context . cursor = cursor; context . resynch = 1; context . flags = flags; context . alist = buffer; context . bufsize = ( bufsize & ~ ( sizeof ( int ) - 1 ) ); context . firstu = context . bufsize; context . put_listent = xfs_attr_put_listent; error = xfs_attr_list_int ( & context );   xfs_attr_list_context_t *context) int error ; xfs_inode_t * dp = context -> dp ; if ( XFS_FORCED_SHUTDOWN ( dp -> i_mount ) )  if ( ! xfs_inode_hasattr ( dp ) )  if ( dp -> i_d . di_aformat == XFS_DINODE_FMT_LOCAL )  if ( xfs_bmap_one_block ( dp , XFS_ATTR_FORK ) )  error = xfs_attr_node_list ( context ); STATIC xfs_attr_node_list(xfs_attr_list_context_t *context) attrlist_cursor_kern_t * cursor ; xfs_attr_leafblock_t * leaf ; xfs_da_intnode_t * node ; struct xfs_attr3_icleaf_hdr leafhdr ; struct xfs_da3_icnode_hdr nodehdr ; struct xfs_da_node_entry * btree ; int error , i ; struct xfs_buf * bp ; struct xfs_inode * dp = context -> dp ; cursor = context -> cursor; cursor -> initted = 1; bp = NULL; if ( cursor -> blkno > 0 )  error = xfs_da3_node_read ( NULL , dp , cursor -> blkno , - 1 , & bp , XFS_ATTR_FORK ); if ( ( error != 0 ) && ( error != - EFSCORRUPTED ) )  if ( bp )  struct xfs_attr_leaf_entry * entries ; node = bp -> b_addr; switch ( be16_to_cpu ( node -> hdr . info . magic ) )  bp = NULL; leaf = bp -> b_addr; entries = xfs_attr3_leaf_entryp ( leaf ); if ( cursor -> hashval > be32_to_cpu ( entries [ leafhdr . count - 1 ] . hashval ) )  bp = NULL; if ( cursor -> hashval <= be32_to_cpu ( entries [ 0 ] . hashval ) )  bp = NULL; bp = NULL; if ( bp == NULL )  cursor -> blkno = 0; __uint16_t magic ; error = xfs_da3_node_read ( NULL , dp , cursor -> blkno , - 1 , & bp , XFS_ATTR_FORK ); if ( error )  node = bp -> b_addr; magic = be16_to_cpu ( node -> hdr . info . magic ); if ( magic == XFS_ATTR_LEAF_MAGIC || magic == XFS_ATTR3_LEAF_MAGIC )  if ( magic != XFS_DA_NODE_MAGIC && magic != XFS_DA3_NODE_MAGIC )  btree = dp -> d_ops -> node_tree_p ( node ); for (i = 0; i < nodehdr.count; btree++, i++) if ( cursor -> hashval <= be32_to_cpu ( btree -> hashval ) )  cursor -> blkno = be32_to_cpu ( btree -> before ); if ( i == nodehdr . count )  error = xfs_attr3_leaf_list_int ( bp , context ); if ( error )  if ( context -> seen_enough || leafhdr . forw == 0 )  cursor -> blkno = leafhdr . forw; error = xfs_attr3_leaf_read ( NULL , dp , cursor -> blkno , - 1 , & bp ); if ( error )    struct struct xfs_attr_list_context	*context) struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; leaf = bp -> b_addr; entries = xfs_attr3_leaf_entryp ( leaf ); cursor = context -> cursor; cursor -> initted = 1; if ( context -> resynch )  entry = & entries [ 0 ]; for (i = 0; i < ichdr.count; entry++, i++) if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval )  if ( cursor -> offset == context -> dupcnt )  context -> dupcnt ++; if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval )  if ( i == ichdr . count )  entry = & entries [ 0 ]; i = 0; context -> resynch = 0; retval = 0; for (; i < ichdr.count; entry++, i++) if ( entry -> flags & XFS_ATTR_INCOMPLETE )  if ( entry -> flags & XFS_ATTR_LOCAL )  xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ); if ( retval )  xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value )  xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ); args . geo = context -> dp -> i_mount -> m_attr_geo; args . dp = context -> dp; args . whichfork = XFS_ATTR_FORK; args . valuelen = valuelen; args . rmtvaluelen = valuelen; args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ); args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ); args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ); retval = xfs_attr_rmtval_get ( & args ); if ( retval )  return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ); kmem_free ( args . value ); retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ); if ( retval )  return retval ; if ( context -> seen_enough )  return retval ; 