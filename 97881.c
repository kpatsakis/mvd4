int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle int AVPacket *avpkt) if ( ! avpkt -> data && avpkt -> size )  if ( ! avctx -> codec )  if ( avctx -> codec -> type != AVMEDIA_TYPE_SUBTITLE )  if ( ( avctx -> codec -> capabilities & AV_CODEC_CAP_DELAY ) || avpkt -> size )  AVPacket tmp = * avpkt ; int did_split = av_packet_split_side_data ( & tmp ) ; if ( did_split )  memset ( tmp . data + tmp . size , 0 , FFMIN ( avpkt -> size - tmp . size , AV_INPUT_BUFFER_PADDING_SIZE ) ); pkt_recoded = tmp; ret = recode_subtitle ( avctx , & pkt_recoded , & tmp ); static int recode_subtitle(AVCodecContext AVPacket *outpkt, const AVPacket *inpkt) if ( avctx -> sub_charenc_mode != FF_SUB_CHARENC_MODE_PRE_DECODER || inpkt -> size == 0 )  cd = iconv_open ( "UTF-8" , avctx -> sub_charenc ); av_assert0 ( cd != ( iconv_t ) - 1 ); inb = inpkt -> data; inl = inpkt -> size; if ( inl >= INT_MAX / UTF8_MAX_BYTES - AV_INPUT_BUFFER_PADDING_SIZE )  av_log ( avctx , AV_LOG_ERROR , "Subtitles packet is too big for recoding\n" ); ret = av_new_packet ( & tmp , inl * UTF8_MAX_BYTES ); if ( ret < 0 )  outpkt -> buf = tmp . buf; outpkt -> data = tmp . data; outpkt -> size = tmp . size; outb = outpkt -> data; outl = outpkt -> size; if ( iconv ( cd , & inb , & inl , & outb , & outl ) == ( size_t ) - 1 || iconv ( cd , NULL , NULL , & outb , & outl ) == ( size_t ) - 1 || outl >= outpkt -> size || inl != 0 )  av_log ( avctx , AV_LOG_ERROR , "Unable to recode subtitle event \"%s\" "from %s to UTF-8\n" , inpkt -> data , avctx -> sub_charenc ) outpkt -> size -= outl; memset ( outpkt -> data + outpkt -> size , 0 , outl ); if ( cd != ( iconv_t ) - 1 )  iconv_close ( cd ); return ret ; if ( ret < 0 )  avctx -> internal -> pkt = & pkt_recoded; if ( avctx -> pkt_timebase . den && avpkt -> pts != AV_NOPTS_VALUE )  sub -> pts = av_rescale_q ( avpkt -> pts , avctx -> pkt_timebase , AV_TIME_BASE_Q ); ret = avctx -> codec -> decode ( avctx , sub , got_sub_ptr , & pkt_recoded ); av_assert1 ( ( ret >= 0 ) >= ! ! * got_sub_ptr && ! ! * got_sub_ptr >= ! ! sub -> num_rects ); if ( sub -> num_rects && ! sub -> end_display_time && avpkt -> duration && avctx -> pkt_timebase . num )  sub -> end_display_time = av_rescale_q ( avpkt -> duration , avctx -> pkt_timebase , ms ); for (i = 0; i < sub->num_rects; i++) if ( sub -> rects [ i ] -> ass && ! utf8_check ( sub -> rects [ i ] -> ass ) )  static int utf8_check(const uint8_t *str) while ( * str )  byte = str; GET_UTF8 ( codepoint , * ( byte ++ ) , return 0 ; min = byte - str == 1 ? 0 : byte - str == 2 ? 0x80 : 1 << ( 5 * ( byte - str ) - 4 ); if ( codepoint < min || codepoint >= 0x110000 || codepoint == 0xFFFE || codepoint >= 0xD800 && codepoint <= 0xDFFF )  str = byte; av_log ( avctx , AV_LOG_ERROR "Invalid UTF-8 in decoded subtitles text; "maybe missing -sub_charenc option\n" ) avsubtitle_free ( sub ); void avsubtitle_free(AVSubtitle *sub) for (i = 0; i < sub->num_rects; i++) av_freep ( & sub -> rects [ i ] -> pict . data [ 0 ] ); av_freep ( & sub -> rects [ i ] -> pict . data [ 1 ] ); av_freep ( & sub -> rects [ i ] -> pict . data [ 2 ] ); av_freep ( & sub -> rects [ i ] -> pict . data [ 3 ] ); av_freep ( & sub -> rects [ i ] -> text ); av_freep ( & sub -> rects [ i ] -> ass ); av_freep ( & sub -> rects [ i ] ); av_freep ( & sub -> rects ); memset ( sub , 0 , sizeof ( AVSubtitle ) ); if ( tmp . data != pkt_recoded . data )  pkt_recoded . side_data = NULL; pkt_recoded . side_data_elems = 0; av_free_packet ( & pkt_recoded ); if ( avctx -> codec_descriptor -> props & AV_CODEC_PROP_BITMAP_SUB )  if ( avctx -> codec_descriptor -> props & AV_CODEC_PROP_TEXT_SUB )  if ( ret == tmp . size )  return ret ; 