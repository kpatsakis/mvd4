static void brcmf_cfg80211_reg_notifier(struct wiphy struct regulatory_request *req) struct brcmf_cfg80211_info * cfg = wiphy_priv ( wiphy ) ; struct brcmf_if * ifp = netdev_priv ( cfg_to_ndev ( cfg ) ) ; s32 err ; int i ; for (i = 0; i < sizeof(req->alpha2); i++) if ( req -> alpha2 [ i ] < 'A' || req -> alpha2 [ i ] > 'Z' )  err = brcmf_fil_iovar_data_get ( ifp , "country" , & ccreq , sizeof ( ccreq ) ); if ( err )  err = brcmf_translate_country_code ( ifp -> drvr , req -> alpha2 , & ccreq ); static s32 brcmf_translate_country_code(struct brcmf_pub *drvr, char struct brcmf_fil_country_le *ccreq) struct brcmfmac_pd_cc * country_codes ; struct brcmfmac_pd_cc_entry * cc ; s32 found_index ; int i ; country_codes = drvr -> settings -> country_codes; if ( ! country_codes )  return - EINVAL ; if ( ( alpha2 [ 0 ] == ccreq -> country_abbrev [ 0 ] ) && ( alpha2 [ 1 ] == ccreq -> country_abbrev [ 1 ] ) )  return - EAGAIN ; found_index = - 1; for (i = 0; i < country_codes->table_size; i++) cc = & country_codes -> table [ i ]; if ( ( cc -> iso3166 [ 0 ] == '\0' ) && ( found_index == - 1 ) )  found_index = i; if ( ( cc -> iso3166 [ 0 ] == alpha2 [ 0 ] ) && ( cc -> iso3166 [ 1 ] == alpha2 [ 1 ] ) )  found_index = i; if ( found_index == - 1 )  return - EINVAL ; return 0 ; if ( err )  err = brcmf_fil_iovar_data_set ( ifp , "country" , & ccreq , sizeof ( ccreq ) ); if ( err )  brcmf_setup_wiphybands ( wiphy ); static int brcmf_setup_wiphybands(struct wiphy *wiphy) struct brcmf_cfg80211_info * cfg = wiphy_priv ( wiphy ) ; struct brcmf_if * ifp = netdev_priv ( cfg_to_ndev ( cfg ) ) ; u32 nmode = 0 ; u32 bw_cap [ 2 ] = { WLC_BW_20MHZ_BIT , WLC_BW_20MHZ_BIT } ; u32 rxchain ; u32 nchain ; int err ; s32 i ; struct ieee80211_supported_band * band ; err = brcmf_fil_iovar_int_get ( ifp , "nmode" , & nmode ); err = brcmf_fil_iovar_int_get ( ifp , "rxchain" , & rxchain ); if ( err )  nchain = 1; for (nchain = 0; rxchain; nchain++) rxchain = rxchain & ( rxchain - 1 ); err = brcmf_construct_chaninfo ( cfg , bw_cap ); static int brcmf_construct_chaninfo(struct brcmf_cfg80211_info u32 bw_cap[]) struct brcmf_if * ifp = netdev_priv ( cfg_to_ndev ( cfg ) ) ; struct ieee80211_supported_band * band ; struct wiphy * wiphy ; struct brcmf_chanspec_list * list ; struct brcmu_chan ch ; int err ; u8 * pbuf ; u32 i , j ; u32 total ; u32 chaninfo ; pbuf = kzalloc ( BRCMF_DCMD_MEDLEN , GFP_KERNEL ); if ( pbuf == NULL )  return - ENOMEM ; list = ( struct brcmf_chanspec_list * ) pbuf; err = brcmf_fil_iovar_data_get ( ifp , "chanspecs" , pbuf , BRCMF_DCMD_MEDLEN ); if ( err )  wiphy = cfg_to_wiphy ( cfg ); band = wiphy -> bands [ NL80211_BAND_2GHZ ]; if ( band )  for (i = 0; i < band->n_channels; i++) band -> channels [ i ] . flags = IEEE80211_CHAN_DISABLED; band = wiphy -> bands [ NL80211_BAND_5GHZ ]; if ( band )  for (i = 0; i < band->n_channels; i++) band -> channels [ i ] . flags = IEEE80211_CHAN_DISABLED; total = le32_to_cpu ( list -> count ); for (i = 0; i < total; i++) ch . chspec = ( u16 ) le32_to_cpu ( list -> element [ i ] ); if ( ch . band == BRCMU_CHAN_BAND_2G )  band = wiphy -> bands [ NL80211_BAND_2GHZ ]; if ( ch . band == BRCMU_CHAN_BAND_5G )  band = wiphy -> bands [ NL80211_BAND_5GHZ ]; if ( ! band )  if ( ! ( bw_cap [ band -> band ] & WLC_BW_40MHZ_BIT ) && ch . bw == BRCMU_CHAN_BW_40 )  if ( ! ( bw_cap [ band -> band ] & WLC_BW_80MHZ_BIT ) && ch . bw == BRCMU_CHAN_BW_80 )  if ( ch . bw == BRCMU_CHAN_BW_80 )  if ( ch . bw == BRCMU_CHAN_BW_40 )  ch . bw = BRCMU_CHAN_BW_20; chaninfo = ch . chspec; err = brcmf_fil_bsscfg_int_get ( ifp , "per_chan_info" , & chaninfo ); return err ; if ( err )  wiphy = cfg_to_wiphy ( cfg ); for (i = 0; i < ARRAY_SIZE(wiphy->bands); i++) band = wiphy -> bands [ i ]; if ( band == NULL )  if ( nmode )  brcmf_update_ht_cap ( band , bw_cap , nchain ); static void brcmf_update_ht_cap(struct ieee80211_supported_band u32 bw_cap[2], u32 nchain) band -> ht_cap . ht_supported = true; if ( bw_cap [ band -> band ] & WLC_BW_40MHZ_BIT )  band -> ht_cap . cap |= IEEE80211_HT_CAP_SGI_40; band -> ht_cap . cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40; band -> ht_cap . cap |= IEEE80211_HT_CAP_SGI_20; band -> ht_cap . cap |= IEEE80211_HT_CAP_DSSSCCK40; band -> ht_cap . ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K; band -> ht_cap . ampdu_density = IEEE80211_HT_MPDU_DENSITY_16; memset ( band -> ht_cap . mcs . rx_mask , 0xff , nchain ); band -> ht_cap . mcs . tx_params = IEEE80211_HT_MCS_TX_DEFINED; 