static s32 brcmf_cfg80211_suspend(struct wiphy struct cfg80211_wowlan *wowl) struct brcmf_cfg80211_info * cfg = wiphy_to_cfg ( wiphy ) ; struct net_device * ndev = cfg_to_ndev ( cfg ) ; struct brcmf_if * ifp = netdev_priv ( ndev ) ; if ( ! check_vif_up ( ifp -> vif ) )  static bool check_vif_up(struct brcmf_cfg80211_vif *vif) if ( ! test_bit ( BRCMF_VIF_STATUS_READY , & vif -> sme_state ) )  return false ; return true ; if ( wowl == NULL )  brcmf_configure_wowl ( cfg , ifp , wowl ); static void brcmf_configure_wowl(struct brcmf_cfg80211_info struct brcmf_if struct cfg80211_wowlan *wowl) if ( wowl -> nd_config )  brcmf_cfg80211_sched_scan_start ( cfg -> wiphy , ifp -> ndev , wowl -> nd_config ); static brcmf_cfg80211_sched_scan_start(struct wiphy struct net_device struct cfg80211_sched_scan_request *request) struct brcmf_if * ifp = netdev_priv ( ndev ) ; struct brcmf_cfg80211_info * cfg = wiphy_priv ( wiphy ) ; if ( test_bit ( BRCMF_SCAN_STATUS_BUSY , & cfg -> scan_status ) )  if ( test_bit ( BRCMF_SCAN_STATUS_SUPPRESS , & cfg -> scan_status ) )  if ( ! request -> n_ssids || ! request -> n_match_sets )  if ( request -> n_match_sets > 0 )  ret = brcmf_dev_pno_clean ( ndev ); static int brcmf_dev_pno_clean(struct net_device *ndev) int ret ; ret = brcmf_fil_iovar_int_set ( netdev_priv ( ndev ) , "pfn" , 0 ); if ( ret == 0 )  ret = brcmf_fil_iovar_data_set ( netdev_priv ( ndev ) , "pfnclear" , NULL , 0 ); return ret ; if ( ret < 0 )  if ( brcmf_dev_pno_config ( ifp , request ) )  static int brcmf_dev_pno_config(struct brcmf_if struct cfg80211_sched_scan_request *request) struct brcmf_pno_param_le pfn_param ; struct brcmf_pno_macaddr_le pfn_mac ; s32 err ; memset ( & pfn_param , 0 , sizeof ( pfn_param ) ); pfn_param . version = cpu_to_le32 ( BRCMF_PNO_VERSION ); pfn_param . flags = cpu_to_le16 ( 1 << BRCMF_PNO_ENABLE_ADAPTSCAN_BIT ); pfn_param . repeat = BRCMF_PNO_REPEAT; pfn_param . exp = BRCMF_PNO_FREQ_EXPO_MAX; pfn_param . scan_freq = cpu_to_le32 ( BRCMF_PNO_TIME ); err = brcmf_fil_iovar_data_set ( ifp , "pfn_set" , & pfn_param , sizeof ( pfn_param ) ); if ( err )  if ( ! ( request -> flags & NL80211_SCAN_FLAG_RANDOM_ADDR ) )  pfn_mac . version = BRCMF_PFN_MACADDR_CFG_VER; pfn_mac . flags = BRCMF_PFN_MAC_OUI_ONLY | BRCMF_PFN_SET_MAC_UNASSOC; memcpy ( pfn_mac . mac , request -> mac_addr , ETH_ALEN ); pfn_mac . mac [ i ] &= mac_mask [ i ]; pfn_mac . mac [ i ] |= get_random_int ( ) & ~ ( mac_mask [ i ] ); pfn_mac . mac [ 0 ] &= 0xFE; pfn_mac . mac [ 0 ] |= 0x02; err = brcmf_fil_iovar_data_set ( ifp , "pfn_macaddr" , & pfn_mac , sizeof ( pfn_mac ) ); if ( err )  brcmf_err ( "pfn_macaddr failed, err=%d\n" , err ); return err ; 