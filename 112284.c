static CVE_2007_6151_VULN_isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) uint minor = iminor ( inode ) ; isdn_ctrl c ; int drvidx ; int i ; char __user * p ; void __user * argp = ( void __user * ) arg ; if ( minor == ISDN_MINOR_STATUS )  switch ( cmd )  if ( arg )  int i ; if ( ! dev -> drivers )  if ( minor <= ISDN_MINOR_BMAX )  if ( minor <= ISDN_MINOR_CTRLMAX )  switch ( cmd )  if ( arg )  dev -> global_flags &= ~ISDN_GLOBAL_STOPPED; drvidx = - 1; if ( arg )  int i ; char * p ; if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  if ( strlen ( iocts . drvid ) )  if ( p = strchr ( iocts . drvid , ',' ) )  * p = 0; drvidx = - 1; for (i = 0; i < ISDN_MAX_DRIVERS; i++) if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  drvidx = i; if ( drvidx == - 1 )  if ( iocts . arg )  dev -> drv [ drvidx ] -> flags &= ~DRV_FLAG_REJBUS; dev -> profd = current; if ( arg )  char __user * p = argp ; int i ; if ( ! access_ok ( VERIFY_WRITE , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  for (i = 0; i < ISDN_MAX_CHANNELS; i++) if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . profile , ISDN_MODEM_NUMREG ) )  p += ISDN_MODEM_NUMREG; if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . pmsn , ISDN_MSNLEN ) )  p += ISDN_MSNLEN; if ( copy_to_user ( p , dev -> mdm . info [ i ] . emu . plmsn , ISDN_LMSNLEN ) )  p += ISDN_LMSNLEN; if ( arg )  char __user * p = argp ; int i ; if ( ! access_ok ( VERIFY_READ , argp , ( ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN ) * ISDN_MAX_CHANNELS ) )  for (i = 0; i < ISDN_MAX_CHANNELS; i++) if ( copy_from_user ( dev -> mdm . info [ i ] . emu . profile , p , ISDN_MODEM_NUMREG ) )  p += ISDN_MODEM_NUMREG; if ( copy_from_user ( dev -> mdm . info [ i ] . emu . plmsn , p , ISDN_LMSNLEN ) )  p += ISDN_LMSNLEN; if ( copy_from_user ( dev -> mdm . info [ i ] . emu . pmsn , p , ISDN_MSNLEN ) )  p += ISDN_MSNLEN; if ( arg )  if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  if ( strlen ( iocts . drvid ) )  drvidx = - 1; for (i = 0; i < ISDN_MAX_DRIVERS; i++) if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  drvidx = i; drvidx = 0; if ( drvidx == - 1 )  if ( cmd == IIOCSETMAP )  int loop = 1 ; p = ( char __user * ) iocts . arg; i = 0; while ( loop )  int j = 0 ; while ( 1 )  if ( ! access_ok ( VERIFY_READ , p , 1 ) )  get_user ( bname [ j ] , p ++ ); switch ( bname [ j ] )  loop = 0; bname [ j ] = '\0'; strcpy ( dev -> drv [ drvidx ] -> msn2eaz [ i ] , bname ); j = ISDN_MSNLEN; j ++; if ( j >= ISDN_MSNLEN )  if ( ++ i > 9 )  p = ( char __user * ) iocts . arg; for (i = 0; i < 10; i++) sprintf ( bname , "%s%s" , strlen ( dev -> drv [ drvidx ] -> msn2eaz [ i ] ) ? dev -> drv [ drvidx ] -> msn2eaz [ i ] : "_" , ( i < 9 ) ? "," : "\0" ); if ( copy_to_user ( p , bname , strlen ( bname ) + 1 ) )  p += strlen ( bname ); if ( ( cmd & IIOCDRVCTL ) == IIOCDRVCTL )  cmd = ( ( cmd >> _IOC_NRSHIFT ) & _IOC_NRMASK ) & ISDN_DRVIOCTL_MASK; if ( arg )  int i ; if ( copy_from_user ( & iocts , argp , sizeof ( isdn_ioctl_struct ) ) )  if ( strlen ( iocts . drvid ) )  drvidx = - 1; for (i = 0; i < ISDN_MAX_DRIVERS; i++) if ( ! ( strcmp ( dev -> drvid [ i ] , iocts . drvid ) ) )  drvidx = i; drvidx = 0; if ( drvidx == - 1 )  if ( ! access_ok ( VERIFY_WRITE , argp , sizeof ( isdn_ioctl_struct ) ) )  c . driver = drvidx; c . command = ISDN_CMD_IOCTL; c . arg = cmd; memcpy ( c . parm . num , & iocts . arg , sizeof ( ulong ) ); ret = isdn_command ( & c ); memcpy ( & iocts . arg , c . parm . num , sizeof ( ulong ) ); if ( copy_to_user ( argp , & iocts , sizeof ( isdn_ioctl_struct ) ) )  return ret ; 