static void xhci_wakeup(USBPort *usbport) XHCIState * xhci = usbport -> opaque ; XHCIPort * port = xhci_lookup_port ( xhci , usbport ) ; static XHCIPort *xhci_lookup_port(XHCIState *xhci, struct USBPort *uport) int index ; if ( ! uport -> dev )  return NULL ; switch ( uport -> dev -> speed )  if ( xhci_get_flag ( xhci , XHCI_FLAG_SS_FIRST ) )  static bool xhci_get_flag(XHCIState *xhci, enum xhci_flags bit) return xhci -> flags & ( 1 << bit ) ; index = uport -> index + xhci -> numports_3; index = uport -> index; if ( xhci_get_flag ( xhci , XHCI_FLAG_SS_FIRST ) )  static bool xhci_get_flag(XHCIState *xhci, enum xhci_flags bit) return xhci -> flags & ( 1 << bit ) ; index = uport -> index; index = uport -> index + xhci -> numports_2; return NULL ; return & xhci -> ports [ index ] ; if ( get_field ( port -> portsc , PORTSC_PLS ) != PLS_U3 )  xhci_port_notify ( port , PORTSC_PLC ); static void xhci_port_notify(XHCIPort *port, uint32_t bits) if ( ( port -> portsc & bits ) == bits )  port -> portsc |= bits; if ( ! xhci_running ( port -> xhci ) )  xhci_event ( port -> xhci , & ev , 0 ); static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v) XHCIInterrupter * intr ; dma_addr_t erdp ; unsigned int dp_idx ; if ( v >= xhci -> numintrs )  intr = & xhci -> intr [ v ]; if ( intr -> er_full )  erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high ); if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )  dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE; assert ( dp_idx < intr -> er_size ); 