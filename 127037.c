 FunctionType::Call(JSContext* unsigned jsval* vp) CallArgs args = CallArgsFromVp ( argc , vp ) ; RootedObject obj ( cx , & args . callee ( ) ) ; if ( ! CData :: IsCData ( obj ) )  RootedObject typeObj ( cx , CData :: GetCType ( obj ) ) ; if ( CType :: GetTypeCode ( typeObj ) != TYPE_pointer )  typeObj = PointerType :: GetBaseType ( typeObj ); if ( CType :: GetTypeCode ( typeObj ) != TYPE_function )  FunctionInfo * fninfo = GetFunctionInfo ( typeObj ) ; uint32_t argcFixed = fninfo -> mArgTypes . length ( ) ; if ( ( ! fninfo -> mIsVariadic && args . length ( ) != argcFixed ) || ( fninfo -> mIsVariadic && args . length ( ) < argcFixed ) )  jsval slot = JS_GetReservedSlot ( obj , SLOT_REFERENT ) ; if ( ! slot . isUndefined ( ) && Library :: IsLibrary ( & slot . toObject ( ) ) )  PRLibrary * library = Library :: GetLibrary ( & slot . toObject ( ) ) ; if ( ! library )  AutoValueAutoArray values ; AutoValueAutoArray strings ; if ( ! values . resize ( args . length ( ) ) )  for (unsigned i = 0; i < argcFixed; ++i) if ( ! ConvertArgument ( cx , args [ i ] , fninfo -> mArgTypes [ i ] , & values [ i ] , & strings ) )  static ConvertArgument(JSContext* HandleValue JSObject* AutoValue* AutoValueAutoArray* strings) if ( ! value -> SizeToType ( cx , type ) )  if ( ! ImplicitConvert ( cx , arg , type , value -> mData , true , & freePointer ) )  static ImplicitConvert(JSContext* HandleValue JSObject* void* bool bool* freePointer) RootedObject targetType ( cx , targetType_ ) ; RootedObject valObj ( cx , nullptr ) ; if ( val . isObject ( ) )  valObj = & val . toObject ( ); if ( CData :: IsCData ( valObj ) )  sourceData = valObj; sourceType = CData :: GetCType ( sourceData ); if ( CType :: TypesEqual ( sourceType , targetType ) )  size_t size = CType :: GetSize ( sourceType ) ; memmove ( buffer , CData :: GetData ( sourceData ) , size ); 