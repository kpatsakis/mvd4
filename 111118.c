static s32 brcmf_cfg80211_suspend(struct wiphy struct cfg80211_wowlan *wowl) struct brcmf_cfg80211_info * cfg = wiphy_to_cfg ( wiphy ) ; struct net_device * ndev = cfg_to_ndev ( cfg ) ; struct brcmf_if * ifp = netdev_priv ( ndev ) ; if ( ! check_vif_up ( ifp -> vif ) )  static bool check_vif_up(struct brcmf_cfg80211_vif *vif) if ( ! test_bit ( BRCMF_VIF_STATUS_READY , & vif -> sme_state ) )  return false ; return true ; if ( wowl == NULL )  brcmf_configure_wowl ( cfg , ifp , wowl ); static void brcmf_configure_wowl(struct brcmf_cfg80211_info struct brcmf_if struct cfg80211_wowlan *wowl) if ( wowl -> nd_config )  brcmf_cfg80211_sched_scan_start ( cfg -> wiphy , ifp -> ndev , wowl -> nd_config ); static brcmf_cfg80211_sched_scan_start(struct wiphy struct net_device struct cfg80211_sched_scan_request *request) struct brcmf_if * ifp = netdev_priv ( ndev ) ; struct brcmf_cfg80211_info * cfg = wiphy_priv ( wiphy ) ; struct brcmf_pno_net_param_le pfn ; int i ; if ( test_bit ( BRCMF_SCAN_STATUS_BUSY , & cfg -> scan_status ) )  if ( test_bit ( BRCMF_SCAN_STATUS_SUPPRESS , & cfg -> scan_status ) )  if ( ! request -> n_ssids || ! request -> n_match_sets )  if ( request -> n_ssids > 0 )  for (i = 0; i < request->n_ssids; i++) if ( request -> n_match_sets > 0 )  ret = brcmf_dev_pno_clean ( ndev ); static int brcmf_dev_pno_clean(struct net_device *ndev) int ret ; ret = brcmf_fil_iovar_int_set ( netdev_priv ( ndev ) , "pfn" , 0 ); if ( ret == 0 )  ret = brcmf_fil_iovar_data_set ( netdev_priv ( ndev ) , "pfnclear" , NULL , 0 ); return ret ; if ( ret < 0 )  if ( brcmf_dev_pno_config ( ifp , request ) )  static int brcmf_dev_pno_config(struct brcmf_if struct cfg80211_sched_scan_request *request) struct brcmf_pno_param_le pfn_param ; struct brcmf_pno_macaddr_le pfn_mac ; s32 err ; u8 * mac_mask ; int i ; memset ( & pfn_param , 0 , sizeof ( pfn_param ) ); pfn_param . version = cpu_to_le32 ( BRCMF_PNO_VERSION ); pfn_param . flags = cpu_to_le16 ( 1 << BRCMF_PNO_ENABLE_ADAPTSCAN_BIT ); pfn_param . repeat = BRCMF_PNO_REPEAT; pfn_param . exp = BRCMF_PNO_FREQ_EXPO_MAX; pfn_param . scan_freq = cpu_to_le32 ( BRCMF_PNO_TIME ); err = brcmf_fil_iovar_data_set ( ifp , "pfn_set" , & pfn_param , sizeof ( pfn_param ) ); if ( err )  return err ; if ( ! ( request -> flags & NL80211_SCAN_FLAG_RANDOM_ADDR ) )  return 0 ; pfn_mac . version = BRCMF_PFN_MACADDR_CFG_VER; pfn_mac . flags = BRCMF_PFN_MAC_OUI_ONLY | BRCMF_PFN_SET_MAC_UNASSOC; memcpy ( pfn_mac . mac , request -> mac_addr , ETH_ALEN ); mac_mask = request -> mac_addr_mask; for (i = 0; i < ETH_ALEN; i++) pfn_mac . mac [ i ] &= mac_mask [ i ]; pfn_mac . mac [ i ] |= get_random_int ( ) & ~ ( mac_mask [ i ] ); pfn_mac . mac [ 0 ] &= 0xFE; pfn_mac . mac [ 0 ] |= 0x02; err = brcmf_fil_iovar_data_set ( ifp , "pfn_macaddr" , & pfn_mac , sizeof ( pfn_mac ) ); return err ; for (i = 0; i < request->n_match_sets; i++) struct cfg80211_ssid * ssid ; u32 ssid_len ; ssid = & request -> match_sets [ i ] . ssid; ssid_len = ssid -> ssid_len; if ( ! ssid_len )  pfn . auth = cpu_to_le32 ( WLAN_AUTH_OPEN ); pfn . wpa_auth = cpu_to_le32 ( BRCMF_PNO_WPA_AUTH_ANY ); pfn . wsec = cpu_to_le32 ( 0 ); pfn . infra = cpu_to_le32 ( 1 ); pfn . flags = cpu_to_le32 ( 1 << BRCMF_PNO_HIDDEN_BIT ); pfn . ssid . SSID_len = cpu_to_le32 ( ssid_len ); memcpy ( pfn . ssid . SSID , ssid -> ssid , ssid_len ); ret = brcmf_fil_iovar_data_set ( ifp , "pfn_add" , & pfn , sizeof ( pfn ) ); brcmf_dbg ( SCAN , ">>> PNO filter %s for ssid (%s)\n" , ret == 0 ? "set" : "failed" , ssid -> ssid ); brcmf_err ( "PNO enable failed!! ret=%d\n" , ret ); 