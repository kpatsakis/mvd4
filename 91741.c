static dissect_capwap_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) proto_item * ti ; proto_tree * capwap_data_tree ; guint offset = 0 ; guint8 type_header ; gboolean fragment_is ; gboolean fragment_more ; guint32 fragment_id ; guint32 fragment_offset ; ti = proto_tree_add_item ( tree , proto_capwap , tvb , 0 , - 1 , ENC_NA ); capwap_data_tree = proto_item_add_subtree ( ti , ett_capwap ); offset += dissect_capwap_preamble ( tvb , capwap_data_tree , offset , & type_header ); static dissect_capwap_preamble(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, guint8 *type_header) guint plen = 0 ; * type_header = lo_nibble ( tvb_get_guint8 ( tvb , offset + plen ) ); plen ++; if ( * type_header == 1 )  plen += 3; return plen ; if ( type_header == 1 )  offset += dissect_capwap_header ( tvb , capwap_data_tree , offset , pinfo , & payload_type , & payload_wbid , & fragment_is , & fragment_more , & fragment_id , & fragment_offset ); static dissect_capwap_header(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, packet_info *pinfo, guint8 *payload_type, guint8 *payload_wbid, gboolean *fragment_is, gboolean *fragment_more, guint32 *fragment_id, guint32 *fragment_offset) guint plen = 0 ; guint8 maclength , wirelesslength ; plen ++; flags = tvb_get_bits16 ( tvb , ( offset + plen ) * 8 + 7 , 9 , ENC_BIG_ENDIAN ); plen += 2; plen += 2; plen += 2; if ( flags & 0x10 )  maclength = tvb_get_guint8 ( tvb , offset + plen ); plen += 1; plen += maclength; align = 4 - ( ( offset + plen ) % 4 ); if ( align != 4 )  plen += align; if ( flags & 0x20 )  wirelesslength = tvb_get_guint8 ( tvb , offset + plen ); if ( global_capwap_draft_8_cisco == 1 )  plen += 1; wirelesslength = 4; plen += 1; plen += wirelesslength; align = 4 - ( ( offset + plen ) % 4 ); if ( align != 4 )  plen += align; return plen ; if ( global_capwap_reassemble && fragment_is )  pinfo -> fragmented = TRUE; frag_msg = fragment_add_check ( tvb , offset , pinfo , fragment_id , capwap_fragment_table , capwap_reassembled_table , fragment_offset , tvb_length_remaining ( tvb , offset ) , fragment_more ); fragment_data fragment_add_check(tvbuff_t *tvb, const int offset, const packet_info const guint32 id, GHashTable GHashTable *reassembled_table, const guint32 const guint32 frag_data_len, const gboolean more_frags) fragment_key key , * new_key , * old_key ; gpointer orig_key , value ; fragment_data * fd_head ; if ( pinfo -> fd -> flags . visited )  key . src = pinfo -> src; key . dst = pinfo -> dst; key . id = id; if ( ! g_hash_table_lookup_extended ( fragment_table , & key , & orig_key , & value ) )  fd_head = new_head ( 0 ); fd_head = value; if ( tvb_reported_length ( tvb ) > tvb_length ( tvb ) )  if ( fragment_add_work ( fd_head , tvb , offset , pinfo , frag_offset , frag_data_len , more_frags ) )  static fragment_add_work(fragment_data *fd_head, tvbuff_t *tvb, const int const packet_info *pinfo, const guint32 const guint32 frag_data_len, const gboolean more_frags) fragment_data * fd ; fragment_data * fd_i ; guint32 max , dfpos ; fd = g_slice_new ( fragment_data ); fd -> next = NULL; fd -> flags = 0; fd -> frame = pinfo -> fd -> num; if ( fd -> frame > fd_head -> frame )  fd_head -> frame = fd -> frame; fd -> offset = frag_offset; fd -> len = frag_data_len; fd -> data = NULL; if ( fd_head -> flags & FD_DEFRAGMENTED && ( frag_offset + frag_data_len ) >= fd_head -> datalen && fd_head -> flags & FD_PARTIAL_REASSEMBLY )  for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) if ( ! fd_i -> data )  fd_i -> data = fd_head -> data + fd_i -> offset; fd_i -> flags |= FD_NOT_MALLOCED; fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); fd_head -> datalen = 0; fd_head -> reassembled_in = 0; if ( ! more_frags )  if ( fd_head -> flags & FD_DATALEN_SET )  if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  fd_head -> flags |= FD_MULTIPLETAILS; fd_head -> datalen = fd -> offset + fd -> len; fd_head -> flags |= FD_DATALEN_SET; if ( fd_head -> flags & FD_DEFRAGMENTED )  if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  max = 0; for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  max = fd_i -> offset + fd_i -> len; if ( max < ( fd_head -> datalen ) )  if ( max > ( fd_head -> datalen ) )  fd_head -> flags |= FD_TOOLONGFRAGMENT; fd_head -> data = g_malloc ( max ); for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) if ( fd_i -> len )  if ( fd_i -> offset + fd_i -> len > dfpos )  if ( fd_i -> offset + fd_i -> len > max )  if ( dfpos < fd_i -> offset )  if ( dfpos - fd_i -> offset > fd_i -> len )  if ( ! fd_head -> data )  if ( fd_i -> offset < dfpos )  fd_i -> flags |= FD_OVERLAP; fd_head -> flags |= FD_OVERLAP; if ( memcmp ( fd_head -> data + fd_i -> offset , fd_i -> data , MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ) )  fd_i -> flags |= FD_OVERLAPCONFLICT; fd_head -> flags |= FD_OVERLAPCONFLICT; memcpy ( fd_head -> data + dfpos , fd_i -> data + ( dfpos - fd_i -> offset ) , fd_i -> len - ( dfpos - fd_i -> offset ) ); if ( fd_i -> flags & FD_NOT_MALLOCED )  fd_i -> flags &= ~FD_NOT_MALLOCED; fd_i -> data = NULL; dfpos = MAX ( dfpos , ( fd_i -> offset + fd_i -> len ) ); fd_head -> flags |= FD_DEFRAGMENTED; fd_head -> reassembled_in = pinfo -> fd -> num; 