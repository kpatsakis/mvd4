static tvbuff_t CVE_2011_1138_PATCHED_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) gint offset = 0 ; gint bit_offset ; guint8 hc1_encoding ; guint8 next_header ; struct ip6_hdr ipv6 ; offset += sizeof ( guint8 ); hc1_encoding = tvb_get_guint8 ( tvb , offset ); next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); offset += sizeof ( guint8 ); if ( hc1_encoding & LOWPAN_HC1_MORE )  if ( next_header == LOWPAN_HC1_NEXT_UDP )  offset += sizeof ( guint8 ); bit_offset = offset << 3; ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_IFC ) )  if ( pinfo -> dst . type == AT_EUI64 )  memcpy ( & ipv6 . ip6_dst . bytes [ 8 ] , pinfo -> dst . data , 8 ); proto_tree_add_ipv6 ( tree , hf_6lowpan_dest , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , ( guint8 * ) & ipv6 . ip6_dst ); ipv6 . ip6_flow = 0; ipv6 . ip6_flow = tvb_get_bits32 ( tvb , bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS , FALSE ); proto_tree_add_uint ( tree , hf_6lowpan_flow_label , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS ) , ipv6 . ip6_flow ); ipv6 . ip6_flow = g_ntohl ( ipv6 . ip6_flow | ( ipv6_class << LOWPAN_IPV6_FLOW_LABEL_BITS ) ); ipv6 . ip6_vfc = ( ( 0x6 << 4 ) | ( ipv6_class >> 4 ) ); ipv6 . ip6_nxt = IP_PROTO_UDP; ipv6 . ip6_nxt = IP_PROTO_ICMPV6; ipv6 . ip6_nxt = IP_PROTO_TCP; ipv6 . ip6_nxt = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ); proto_tree_add_uint_format ( tree , hf_6lowpan_next_header , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ) , ipv6 . ip6_nxt , "Next header: %s (0x%02x)" , ipprotostr ( ipv6 . ip6_nxt ) , ipv6 . ip6_nxt ); nhdr_list -> proto = ipv6 . ip6_nxt; nhdr_list -> length = length; nhdr_list -> reported = tvb_reported_length_remaining ( tvb , offset ); tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) , offset , nhdr_list -> length ); ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); return ipv6_tvb ; 