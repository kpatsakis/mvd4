static ppp_channel_push(struct channel *pch) struct ppp * ppp ; if ( skb_queue_empty ( & pch -> file . xq ) )  ppp = pch -> ppp; if ( ppp )  ppp_xmit_process ( ppp ); static ppp_xmit_process(struct ppp *ppp) if ( ! ppp -> closing )  ppp_push ( ppp ); static ppp_push(struct ppp *ppp) struct list_head * list ; struct sk_buff * skb = ppp -> xmit_pending ; if ( ! skb )  list = & ppp -> channels; if ( list_empty ( list ) )  if ( ( ppp -> flags & SC_MULTILINK ) == 0 )  if ( ! ppp_mp_explode ( ppp , skb ) )  static int ppp_mp_explode(struct ppp *ppp, struct sk_buff *skb) int len , totlen ; int i , bits , hdrlen , mtu ; int flen ; int navail , nfree , nzero ; int nbigger ; int totspeed ; int totfree ; unsigned char * p , * q ; struct list_head * list ; struct channel * pch ; struct sk_buff * frag ; totspeed = 0; nfree = 0; navail = 0; nzero = 0; totfree = 0; hdrlen = ( ppp -> flags & SC_MP_XSHORTSEQ ) ? MPHDRLEN_SSN : MPHDRLEN; i = 0; if ( pch -> chan )  pch -> avail = 1; navail ++; pch -> speed = pch -> chan -> speed; pch -> avail = 0; if ( pch -> avail )  if ( skb_queue_empty ( & pch -> file . xq ) || ! pch -> had_frag )  if ( pch -> speed == 0 )  nzero ++; totspeed += pch -> speed; pch -> avail = 2; if ( ! pch -> had_frag && i < ppp -> nxchan )  ppp -> nxchan = i; if ( nfree == 0 || nfree < navail / 2 )  p = skb -> data; len = skb -> len; totlen = len; nbigger = len % nfree; list = & ppp -> channels; for (i = 0; i < ppp->nxchan; ++i) list = list -> next; if ( list == & ppp -> channels )  bits = B; while ( len > 0 )  list = list -> next; if ( list == & ppp -> channels )  pch = list_entry ( list , struct channel , clist ) if ( ! pch -> avail )  if ( pch -> avail == 1 )  if ( nfree > 0 )  pch -> avail = 1; if ( pch -> chan == NULL )  if ( pch -> speed == 0 )  nzero --; totspeed -= pch -> speed; pch -> avail = 0; totlen = len; totfree --; nfree --; if ( -- navail == 0 )  flen = len; if ( nfree > 0 )  if ( pch -> speed == 0 )  flen = len / nfree; if ( nbigger > 0 )  flen ++; nbigger --; flen = ( ( ( totfree - nzero ) * ( totlen + hdrlen * totfree ) ) / ( ( totspeed * totfree ) / pch -> speed ) ) - hdrlen; if ( nbigger > 0 )  flen += ( ( totfree - nzero ) * pch -> speed ) / totspeed; nbigger -= ( ( totfree - nzero ) * pch -> speed ) / totspeed; nfree --; if ( ( nfree <= 0 ) || ( flen > len ) )  flen = len; if ( flen <= 0 )  pch -> avail = 2; mtu = pch -> chan -> mtu - ( hdrlen - 2 ); if ( mtu < 4 )  mtu = 4; if ( flen > mtu )  flen = mtu; if ( flen == len )  bits |= E; frag = alloc_skb ( flen + hdrlen + ( flen == 0 ) , GFP_ATOMIC ); if ( ! frag )  q = skb_put ( frag , flen + hdrlen ); if ( ppp -> flags & SC_MP_XSHORTSEQ )  q [ 2 ] = bits; q [ 3 ] = ppp -> nxseq >> 16; q [ 4 ] = ppp -> nxseq >> 8; q [ 5 ] = ppp -> nxseq; memcpy ( q + hdrlen , p , flen ); pch -> had_frag = 1; p += flen; len -= flen; bits = 0; 