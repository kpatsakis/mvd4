static int get_scsi_requests(QEMUFile *f, void *pv, size_t size) SCSIDevice * s = pv ; int8_t sbyte ; while ( ( sbyte = qemu_get_sbyte ( f ) ) > 0 )  uint8_t buf [ SCSI_CMD_BUF_SIZE ] ; uint32_t tag ; uint32_t lun ; SCSIRequest * req ; req = scsi_req_new ( s , tag , lun , buf , NULL ); SCSIRequest *scsi_req_new(SCSIDevice *d, uint32_t tag, uint32_t uint8_t *buf, void *hba_private) SCSIBus * bus = DO_UPCAST ( SCSIBus , qbus , d -> qdev . parent_bus ) ; const SCSIReqOps * ops ; SCSIDeviceClass * sc = SCSI_DEVICE_GET_CLASS ( d ) ; SCSIRequest * req ; SCSICommand cmd = . len = 0 int ret ; if ( ( d -> unit_attention . key == UNIT_ATTENTION || bus -> unit_attention . key == UNIT_ATTENTION ) && ( buf [ 0 ] != INQUIRY && buf [ 0 ] != REPORT_LUNS && buf [ 0 ] != GET_CONFIGURATION && buf [ 0 ] != GET_EVENT_STATUS_NOTIFICATION && ! ( buf [ 0 ] == REQUEST_SENSE && d -> sense_is_ua ) ) )  ops = & reqops_unit_attention; if ( lun != d -> lun || buf [ 0 ] == REPORT_LUNS || ( buf [ 0 ] == REQUEST_SENSE && d -> sense_len ) )  ops = & reqops_target_command; ops = NULL; if ( ops != NULL || ! sc -> parse_cdb )  ret = scsi_req_parse_cdb ( d , & cmd , buf ); ret = sc -> parse_cdb ( d , & cmd , buf , hba_private ); if ( ret != 0 )  if ( cmd . xfer > INT32_MAX )  req = scsi_req_alloc ( & reqops_invalid_field , d , tag , lun , hba_private ); SCSIRequest *scsi_req_alloc(const SCSIReqOps *reqops, SCSIDevice uint32_t tag, uint32_t lun, void *hba_private) SCSIRequest * req ; const int memset_off = offsetof ( SCSIRequest , sense ) + sizeof ( req -> sense ) ; req = g_slice_alloc ( reqops -> size ); memset ( ( uint8_t * ) req + memset_off , 0 , reqops -> size - memset_off ); 