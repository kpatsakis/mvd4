static int sctp_setsockopt(struct sock *sk, int level, int char __user *optval, unsigned int optlen) if ( level != SOL_SCTP )  switch ( optname )  retval = sctp_setsockopt_connectx_old ( sk , ( struct sockaddr __user * ) optval , optlen ); static int sctp_setsockopt_connectx_old(struct sock struct sockaddr __user int addrs_size) return __sctp_setsockopt_connectx ( sk , addrs , addrs_size , NULL ) ; static int __sctp_setsockopt_connectx(struct sock struct sockaddr __user int sctp_assoc_t *assoc_id) struct sockaddr * kaddrs ; gfp_t gfp = GFP_KERNEL ; if ( unlikely ( addrs_size <= 0 ) )  if ( unlikely ( ! access_ok ( VERIFY_READ , addrs , addrs_size ) ) )  if ( sk -> sk_socket -> file )  gfp = GFP_USER | __GFP_NOWARN; kaddrs = kmalloc ( addrs_size , gfp ); if ( unlikely ( ! kaddrs ) )  if ( __copy_from_user ( kaddrs , addrs , addrs_size ) )  err = __sctp_connect ( sk , kaddrs , addrs_size , assoc_id ); static int __sctp_connect(struct sock struct sockaddr int sctp_assoc_t *assoc_id) struct net * net = sock_net ( sk ) ; struct sctp_sock * sp ; struct sctp_endpoint * ep ; struct sctp_association * asoc = NULL ; struct sctp_association * asoc2 ; struct sctp_transport * transport ; union sctp_addr to ; sctp_scope_t scope ; int walk_size = 0 ; void * addr_buf ; unsigned short port ; sp = sctp_sk ( sk ); ep = sp -> ep; if ( sctp_sstate ( sk , ESTABLISHED ) || sctp_sstate ( sk , CLOSING ) || ( sctp_style ( sk , TCP ) && sctp_sstate ( sk , LISTENING ) ) )  addr_buf = kaddrs; while ( walk_size < addrs_size )  struct sctp_af * af ; if ( walk_size + sizeof ( sa_family_t ) > addrs_size )  sa_addr = addr_buf; af = sctp_get_af_specific ( sa_addr -> sa . sa_family ); if ( ! af || ( walk_size + af -> sockaddr_len ) > addrs_size )  port = ntohs ( sa_addr -> v4 . sin_port ); memcpy ( & to , sa_addr , af -> sockaddr_len ); err = sctp_verify_addr ( sk , & to , af -> sockaddr_len ); if ( err )  if ( asoc && asoc -> peer . port && asoc -> peer . port != port )  asoc2 = sctp_endpoint_lookup_assoc ( ep , & to , & transport ); if ( asoc2 && asoc2 != asoc )  if ( asoc2 -> state >= SCTP_STATE_ESTABLISHED )  if ( sctp_endpoint_is_peeled_off ( ep , & to ) )  if ( ! asoc )  if ( ! ep -> base . bind_addr . port )  if ( sctp_autobind ( sk ) )  if ( ep -> base . bind_addr . port < PROT_SOCK && ! ns_capable ( net -> user_ns , CAP_NET_BIND_SERVICE ) )  scope = sctp_scope ( & to ); asoc = sctp_association_new ( ep , sk , scope , GFP_KERNEL ); if ( ! asoc )  err = sctp_assoc_set_bind_addr_from_ep ( asoc , scope , GFP_KERNEL ); if ( err < 0 )  transport = sctp_assoc_add_peer ( asoc , & to , GFP_KERNEL , SCTP_UNKNOWN ); if ( ! transport )  addr_buf += af -> sockaddr_len; walk_size += af -> sockaddr_len; pr_debug ( "%s: took out_free path with asoc:%p kaddrs:%p err:%d\n" , __func__ , asoc , kaddrs , err ); return err ; 