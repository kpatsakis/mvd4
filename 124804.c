static int apng_encode_frame(AVCodecContext *avctx, const AVFrame APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) PNGEncContext * s = avctx -> priv_data ; int ret ; AVFrame * diffFrame ; uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; uint8_t * original_bytestream , * original_bytestream_end ; uint8_t * best_bytestream ; size_t best_bytestream_size = SIZE_MAX ; APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; APNGFctlChunk fctl_chunk = * best_fctl_chunk ; if ( avctx -> frame_number == 0 )  diffFrame = av_frame_alloc ( ); if ( ! diffFrame )  diffFrame -> format = pict -> format; diffFrame -> width = pict -> width; diffFrame -> height = pict -> height; if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  original_bytestream = s -> bytestream; original_bytestream_end = s -> bytestream_end; temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); if ( ! temp_bytestream )  for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) uint32_t original_sequence_number = s -> sequence_number , sequence_number ; uint8_t * bytestream_start = s -> bytestream ; size_t bytestream_size ; if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  if ( ! s -> prev_frame )  memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  ret = encode_frame ( avctx , diffFrame ); s -> sequence_number = original_sequence_number; bytestream_size = s -> bytestream - bytestream_start; s -> bytestream = bytestream_start; if ( ret < 0 )  if ( bytestream_size < best_bytestream_size )  best_bytestream = s -> bytestream; best_bytestream_size = bytestream_size; if ( best_bytestream == original_bytestream )  s -> bytestream = temp_bytestream; s -> bytestream_end = temp_bytestream_end; s -> bytestream = original_bytestream; s -> bytestream_end = original_bytestream_end; static int encode_frame(AVCodecContext *avctx, const AVFrame *pict) PNGEncContext * s = avctx -> priv_data ; int y , len , ret ; int row_size , pass_row_size ; row_size = ( pict -> width * s -> bits_per_pixel + 7 ) >> 3; crow_base = av_malloc ( ( row_size + 32 ) << ( s -> filter_type == PNG_FILTER_VALUE_MIXED ) ); if ( ! crow_base )  if ( s -> is_progressive )  progressive_buf = av_malloc ( row_size + 1 ); top_buf = av_malloc ( row_size + 1 ); if ( ! progressive_buf || ! top_buf )  s -> zstream . avail_out = IOBUF_SIZE; s -> zstream . next_out = s -> buf; ret = deflate ( & s -> zstream , Z_FINISH ); if ( ret == Z_OK || ret == Z_STREAM_END )  len = IOBUF_SIZE - s -> zstream . avail_out; if ( len > 0 && s -> bytestream_end - s -> bytestream > len + 100 )  png_write_image_data ( avctx , s -> buf , len ); s -> zstream . avail_out = IOBUF_SIZE; s -> zstream . next_out = s -> buf; if ( ret == Z_STREAM_END )  static void png_write_image_data(AVCodecContext const uint8_t *buf, int length) PNGEncContext * s = avctx -> priv_data ; if ( avctx -> codec_id == AV_CODEC_ID_PNG || avctx -> frame_number == 0 )  png_write_chunk ( & s -> bytestream , MKTAG ( 'I' , 'D' , 'A' , 'T' ) , buf , length ); static void png_write_chunk(uint8_t **f, uint32_t const uint8_t *buf, int length) if ( length > 0 )  memcpy ( * f , buf , length ); * f += length; bytestream_put_be32 ( f , ~crc ); 