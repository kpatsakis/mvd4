static tvbuff_t CVE_2011_1138_VULN_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) gint offset = 0 ; gint bit_offset ; int i ; guint8 hc1_encoding ; guint8 hc_udp_encoding = 0 ; guint8 next_header ; struct ip6_hdr ipv6 ; struct lowpan_nhdr * nhdr_list ; offset += sizeof ( guint8 ); hc1_encoding = tvb_get_guint8 ( tvb , offset ); next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); offset += sizeof ( guint8 ); if ( hc1_encoding & LOWPAN_HC1_MORE )  if ( next_header == LOWPAN_HC1_NEXT_UDP )  hc_udp_encoding = tvb_get_guint8 ( tvb , offset ); offset += sizeof ( guint8 ); bit_offset = offset << 3; ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); bit_offset += LOWPAN_IPV6_HOP_LIMIT_BITS; offset = bit_offset; if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_PREFIX ) )  for (i=0; i<8; i++, bit_offset += 8) ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); memcpy ( ipv6 . ip6_src . bytes , lowpan_llprefix , sizeof ( lowpan_llprefix ) ); if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_IFC ) )  for (i=8; i<16; i++, bit_offset += 8) ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); if ( pinfo -> src . type == AT_EUI64 )  memcpy ( & ipv6 . ip6_src . bytes [ 8 ] , pinfo -> src . data , 8 ); offset = bit_offset; if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_PREFIX ) )  for (i=0; i<8; i++, bit_offset += 8) ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_IFC ) )  for (i=8; i<16; i++, bit_offset += 8) if ( ! ( hc1_encoding & LOWPAN_HC1_TRAFFIC_CLASS ) )  bit_offset += LOWPAN_IPV6_TRAFFIC_CLASS_BITS; bit_offset += LOWPAN_IPV6_FLOW_LABEL_BITS; if ( next_header == LOWPAN_HC1_NEXT_UDP )  if ( next_header == LOWPAN_HC1_NEXT_ICMP )  if ( next_header == LOWPAN_HC1_NEXT_TCP )  bit_offset += LOWPAN_IPV6_NEXT_HEADER_BITS; if ( ( hc1_encoding & LOWPAN_HC1_MORE ) && ( next_header == LOWPAN_HC1_NEXT_UDP ) )  struct udp_hdr udp ; gint length ; offset = bit_offset; if ( hc_udp_encoding & LOWPAN_HC2_UDP_SRCPORT )  udp . src_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; udp . src_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); bit_offset += LOWPAN_UDP_PORT_BITS; udp . src_port = g_ntohs ( udp . src_port ); offset = bit_offset; if ( hc_udp_encoding & LOWPAN_HC2_UDP_DSTPORT )  udp . dst_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; udp . dst_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); bit_offset += LOWPAN_UDP_PORT_BITS; udp . dst_port = g_ntohs ( udp . dst_port ); if ( ! ( hc_udp_encoding & LOWPAN_HC2_UDP_LENGTH ) )  udp . length = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_LENGTH_BITS , FALSE ); bit_offset += LOWPAN_UDP_LENGTH_BITS; if ( dgram_size >= 0 )  if ( dgram_size < ( gint ) sizeof ( struct ip6_hdr ) )  udp . length = dgram_size - ( gint ) sizeof ( struct ip6_hdr ); udp . length = tvb_reported_length ( tvb ); udp . length -= BITS_TO_BYTE_LEN ( 0 , bit_offset + LOWPAN_UDP_CHECKSUM_BITS ); udp . length += sizeof ( struct udp_hdr ); udp . length = g_ntohs ( udp . length ); udp . checksum = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_CHECKSUM_BITS , FALSE ); bit_offset += LOWPAN_UDP_CHECKSUM_BITS; udp . checksum = g_ntohs ( udp . checksum ); offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); length = tvb_length_remaining ( tvb , offset ); nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + sizeof ( struct udp_hdr ) + length ); nhdr_list -> next = NULL; nhdr_list -> proto = IP_PROTO_UDP; nhdr_list -> length = length + sizeof ( struct udp_hdr ); nhdr_list -> reported = g_ntohs ( udp . length ); memcpy ( LOWPAN_NHDR_DATA ( nhdr_list ) , & udp , sizeof ( struct udp_hdr ) ); 