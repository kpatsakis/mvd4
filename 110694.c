static int unix_seqpacket_sendmsg(struct socket *sock, struct msghdr size_t len) int err ; struct sock * sk = sock -> sk ; err = sock_error ( sk ); if ( err )  if ( sk -> sk_state != TCP_ESTABLISHED )  if ( msg -> msg_namelen )  msg -> msg_namelen = 0; return unix_dgram_sendmsg ( sock , msg , len ) ; static int unix_dgram_sendmsg(struct socket *sock, struct msghdr size_t len) struct sock * sk = sock -> sk ; struct unix_sock * u = unix_sk ( sk ) ; int err ; err = scm_send ( sock , msg , & scm , false ); if ( err < 0 )  err = - EOPNOTSUPP; if ( msg -> msg_flags & MSG_OOB )  if ( msg -> msg_namelen )  err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ); if ( err < 0 )  other = unix_peer_get ( sk ); if ( ! other )  if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 )  static int unix_autobind(struct socket *sock) struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; static u32 ordernum = 1 ; struct unix_address * addr ; int err ; unsigned int retries = 0 ; err = mutex_lock_interruptible ( & u -> readlock ); if ( err )  if ( u -> addr )  addr = kzalloc ( sizeof ( * addr ) + sizeof ( short ) + 16 , GFP_KERNEL ); if ( ! addr )  addr -> name -> sun_family = AF_UNIX; addr -> len = sprintf ( addr -> name -> sun_path + 1 , "%05x" , ordernum ) + 1 + sizeof ( short ); addr -> hash = unix_hash_fold ( csum_partial ( addr -> name , addr -> len , 0 ) ); ordernum = ( ordernum + 1 ) & 0xFFFFF; if ( __unix_find_socket_byname ( net , addr -> name , addr -> len , sock -> type , addr -> hash ) )  if ( retries ++ == 0xFFFFF )  static struct sock *__unix_find_socket_byname(struct net struct sockaddr_un int len, int type, unsigned int hash) struct sock * s ; struct unix_sock * u = unix_sk ( s ) ; if ( u -> addr -> len == len && ! memcmp ( u -> addr -> name , sunname , len ) )  