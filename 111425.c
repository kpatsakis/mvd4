static int encode_png(AVCodecContext *avctx, AVPacket const AVFrame *pict, int *got_packet) PNGEncContext * s = avctx -> priv_data ; int ret ; int enc_row_size ; size_t max_packet_size ; enc_row_size = deflateBound ( & s -> zstream , ( avctx -> width * s -> bits_per_pixel + 7 ) >> 3 ); max_packet_size = AV_INPUT_BUFFER_MIN_SIZE + avctx -> height * ( enc_row_size + 12 * ( ( ( int64_t ) enc_row_size + IOBUF_SIZE - 1 ) / IOBUF_SIZE ) ); if ( max_packet_size > INT_MAX )  ret = ff_alloc_packet2 ( avctx , pkt , max_packet_size , 0 ); if ( ret < 0 )  ret = encode_headers ( avctx , pict ); static int encode_headers(AVCodecContext *avctx, const AVFrame *pict) return 0 ; if ( ret < 0 )  ret = encode_frame ( avctx , pict ); static int encode_frame(AVCodecContext *avctx, const AVFrame *pict) PNGEncContext * s = avctx -> priv_data ; const AVFrame * const p = pict int y , len , ret ; int row_size , pass_row_size ; uint8_t * ptr , * top , * crow_buf , * crow ; row_size = ( pict -> width * s -> bits_per_pixel + 7 ) >> 3; crow_base = av_malloc ( ( row_size + 32 ) << ( s -> filter_type == PNG_FILTER_VALUE_MIXED ) ); if ( ! crow_base )  crow_buf = crow_base + 15; if ( s -> is_progressive )  progressive_buf = av_malloc ( row_size + 1 ); top_buf = av_malloc ( row_size + 1 ); if ( ! progressive_buf || ! top_buf )  s -> zstream . avail_out = IOBUF_SIZE; s -> zstream . next_out = s -> buf; if ( s -> is_progressive )  top = NULL; for (y = 0; y < pict->height; y++) ptr = p -> data [ 0 ] + y * p -> linesize [ 0 ]; crow = png_choose_filter ( s , crow_buf , ptr , top , row_size , s -> bits_per_pixel >> 3 ); top = ptr; static uint8_t *png_choose_filter(PNGEncContext *s, uint8_t uint8_t *src, uint8_t *top, int size, int bpp) int pred = s -> filter_type ; if ( ! top && pred )  pred = PNG_FILTER_VALUE_SUB; if ( pred == PNG_FILTER_VALUE_MIXED )  png_filter_row ( s , dst + 1 , pred , src , top , size , bpp ); static void png_filter_row(PNGEncContext *c, uint8_t *dst, int uint8_t *src, uint8_t *top, int size, int bpp) switch ( filter_type )  memcpy ( dst , src , size ); sub_left_prediction ( c , dst , src , bpp , size ); static void sub_left_prediction(PNGEncContext *c, uint8_t *dst, const uint8_t *src, int bpp, int size) const uint8_t * src1 = src + bpp ; const uint8_t * src2 = src ; memcpy ( dst , src , bpp ); dst += bpp; size -= bpp; unaligned_w = FFMIN ( 32 - bpp , size ); for (x = 0; x < unaligned_w; x++) * dst ++ = * src1 ++ - * src2 ++; size -= unaligned_w; c -> hdsp . diff_bytes ( dst , src1 , src2 , size ); c -> hdsp . diff_bytes ( dst , src , top , size ); dst [ i ] = src [ i ] - ( top [ i ] >> 1 ); for (; i < size; i++) dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) >> 1 ); for (i = 0; i < bpp; i++) dst [ i ] = src [ i ] - top [ i ]; sub_png_paeth_prediction ( dst + i , src + i , top + i , size - i , bpp ); static void sub_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t int w, int bpp) for (i = 0; i < w; i++) a = src [ i - bpp ]; b = top [ i ]; c = top [ i - bpp ]; p = b - c; pc = a - c; pa = abs ( p ); pb = abs ( pc ); pc = abs ( p + pc ); if ( pa <= pb && pa <= pc )  p = a; if ( pb <= pc )  p = b; p = c; dst [ i ] = src [ i ] - p; 