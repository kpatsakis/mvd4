status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) uint32_t hdr [ 2 ] ; if ( mDataSource -> readAt ( * offset , hdr , 8 ) < 8 )  uint64_t chunk_size = ntohl ( hdr [ 0 ] ) ; off64_t data_offset = * offset + 8 ; if ( chunk_size == 1 )  if ( mDataSource -> readAt ( * offset + 8 , & chunk_size , 8 ) < 8 )  chunk_size = ntoh64 ( chunk_size ); data_offset += 8; if ( chunk_size < 16 )  if ( chunk_size < 8 )  char buffer [ 256 ] ; if ( chunk_type == FOURCC ( 's' , 't' , 'b' , 'l' ) )  if ( mDataSource -> flags ( ) & ( DataSource :: kWantsPrefetching | DataSource :: kIsCachingDataSource ) )  sp < MPEG4DataSource > cachedSource = new MPEG4DataSource ( mDataSource ) ; MPEG4DataSource::MPEG4DataSource(const sp<DataSource> &source) if ( cachedSource -> setCachedRange ( * offset , chunk_size ) == OK )  mDataSource = cachedSource; mLastTrack -> sampleTable = new SampleTable ( mDataSource ); bool isTrack = false ; if ( chunk_type == FOURCC ( 't' , 'r' , 'a' , 'k' ) )  isTrack = true; Track * track = new Track track -> next = NULL; if ( mLastTrack )  mLastTrack -> next = track; mFirstTrack = track; mLastTrack = track; track -> meta = new MetaData off64_t stop_offset = * offset + chunk_size ; * offset = data_offset; while ( * offset < stop_offset )  status_t err = parseChunk ( offset , depth + 1 ) ; if ( err != OK )  if ( * offset != stop_offset )  if ( isTrack )  if ( mLastTrack -> skipTrack )  Track * cur = mFirstTrack ; if ( cur == mLastTrack )  delete mLastTrack uint8_t version ; PsshInfo pssh ; if ( mDataSource -> readAt ( data_offset , & version , 4 ) < 4 )  if ( mDataSource -> readAt ( data_offset + 4 , & pssh . uuid , 16 ) < 16 )  pssh . datalen = chunk_data_size + 8; pssh . data = new uint8_t [ pssh . datalen ]; if ( chunk_data_size < 8 )  uint8_t buffer [ 8 ] ; uint8_t buffer [ 8 + 20 ] ; uint8_t buffer [ 78 ] ; if ( chunk_data_size < 8 )  char buffer [ 18 ] ; if ( chunk_data_size < 4 )  uint8_t buffer [ 256 ] ; sp < ABuffer > buffer = new ABuffer ( chunk_data_size ) ; char buffer [ 23 ] ; uint8_t buffer [ 4 ] ; uint32_t buffer ; const void * data ; size_t size = 0 ; if ( ! mLastTrack -> meta -> findData ( kKeyTextFormatData , & type , & data , & size ) )  size = 0; uint8_t * buffer = new uint8_t [ size + chunk_size ] ; if ( size > 0 )  memcpy ( buffer , data , size ); if ( ( size_t ) ( mDataSource -> readAt ( * offset , buffer + size , chunk_size ) ) < chunk_size )  delete [ ] buffer mLastTrack -> meta -> setData ( kKeyTextFormatData , 0 , buffer , size + chunk_size ); delete [ ] buffer if ( mFileMetaData != NULL )  sp < ABuffer > buffer = new ABuffer ( chunk_data_size + 1 ) ; if ( mDataSource -> readAt ( data_offset , buffer -> data ( ) , chunk_data_size ) != ( ssize_t ) chunk_data_size )  mFileMetaData -> setData ( kKeyAlbumArt , MetaData :: TYPE_NONE , buffer -> data ( ) + kSkipBytesOfDataBox , chunk_data_size - kSkipBytesOfDataBox ); 